**بخش پاسخ**

موضوع اصلی: پیاده‌سازی تکلیف و توضیحات مربوط به ساختارها و متدها در Rust

این بخش شامل پیاده‌سازی گام به گام تکلیف بالا به همراه توضیحات و نکات مربوطه است که بر اساس اطلاعات ارائه شده در منابع شما نوشته شده است.

راه حل گام به گام:

**گام 1: تعریف ساختار Product**

برای شروع، ساختار `Product` را با فیلدهای مشخص شده تعریف می‌کنیم. تعریف یک ساختار با کلمه کلیدی `struct` و نام ساختار شروع می‌شود و سپس داخل آکولاد `{}`، نام فیلدها و نوع داده آن‌ها مشخص می‌شود.

```

struct Product {

    name: String,

    price: f64,

    quantity: u32,

}

```

یادآوری: ساختارها به شما اجازه می‌دهند چندین مقدار مرتبط را که یک گروه معنادار را تشکیل می‌دهند، بسته‌بندی و نام‌گذاری کنید. برخلاف تاپل‌ها (tuples)، هر قسمت از داده در ساختار نام مشخصی دارد که وضوح کد را افزایش می‌دهد.

**گام 2: ایجاد نمونه اولیه**

در تابع `main`، یک نمونه اولیه از ساختار `Product` ایجاد می‌کنیم. این کار با نوشتن نام ساختار و سپس آکولاد شامل زوج‌های `کلید: مقدار` انجام می‌شود، جایی که کلیدها نام فیلدها و مقادیر، داده‌هایی هستند که می‌خواهیم در آن فیلدها ذخیره کنیم.

```

fn main() {

    let product1 = Product {

        name: String::from("لپ تاپ"),

        price: 1200.50,

        quantity: 10,

    };

    // ادامه کد در گام های بعدی اضافه خواهد شد

}

```

نکات مهم: در اینجا از `String::from` برای ایجاد یک مقدار `String` از یک string literal استفاده کرده‌ایم. منابع نشان می‌دهند که برای فیلدهایی که مالکیت داده‌ها را نیاز دارند، از نوع `String` استفاده می‌شود.

**گام 3: تغییر مقدار فیلد**

برای تغییر مقدار یک فیلد در یک نمونه ساختار، نمونه باید قابل تغییر (mutable) اعلام شده باشد (با استفاده از کلمه کلیدی `mut`) و از نقطه (.) برای دسترسی به فیلد مورد نظر استفاده می‌شود.

```

fn main() {

    let mut product1 = Product { // اضافه کردن mut برای قابل تغییر کردن

        name: String::from("لپ تاپ"),

        price: 1200.50,

        quantity: 10,

    };


    println!("تعداد اولیه: {}", product1.quantity); // چاپ قبل از تغییر


    product1.quantity = 8; // تغییر مقدار فیلد quantity


    println!("تعداد بعد از تغییر: {}", product1.quantity); // چاپ بعد از تغییر

    // ادامه کد در گام های بعدی اضافه خواهد شد

}

```

نکات مهم: در Rust، یا کل نمونه ساختار باید قابل تغییر باشد یا هیچ کدام از فیلدهای آن قابل تغییر نخواهند بود.

**گام 4: تابع create_product با Field Init Shorthand**

می‌توانیم تابعی بنویسیم که یک نمونه از ساختار را برگرداند. اگر نام پارامترهای تابع با نام فیلدهای ساختار که می‌خواهیم مقداردهی کنیم یکسان باشد، می‌توانیم از Field Init Shorthand استفاده کنیم.

```

struct Product {

    name: String,

    price: f64,

    quantity: u32,

}


fn create_product(name: String, price: f64) -> Product { // تابعی برای ساخت محصول با quantity اولیه 1

    Product {

        name, // استفاده از field init shorthand به جای name: name

        price, // استفاده از field init shorthand به جای price: price

        quantity: 1, // مقداردهی صریح فیلد quantity

    }

}


fn main() {

    let mut product1 = Product { /* ... */ }; // کد از گام 3


    let product_mouse = create_product(String::from("ماوس"), 25.0); // استفاده از تابع سازنده

    println!("محصول جدید با تابع سازنده: نام: {}, قیمت: {}, تعداد: {}",

             product_mouse.name, product_mouse.price, product_mouse.quantity);

    // ادامه کد در گام های بعدی اضافه خواهد شد

}

```

نکات مهم: Field Init Shorthand کد را کوتاه‌تر و خواناتر می‌کند زمانی که نام پارامترها و فیلدها یکسان است.

**گام 5: ساخت نمونه جدید با Struct Update Syntax**

برای ایجاد یک نمونه جدید که بیشتر مقادیر آن از یک نمونه موجود گرفته شده است، می‌توان از Struct Update Syntax (`..`) استفاده کرد. این نحو (`..`) مشخص می‌کند که فیلدهای باقی‌مانده که صریحاً مقداردهی نشده‌اند، باید همان مقادیر متناظر در نمونه داده شده را داشته باشند.

```

struct Product {

    name: String,

    price: f64,

    quantity: u32,

}


fn create_product(name: String, price: f64) -> Product { /* ... */ } // کد از گام 4


fn main() {

    let mut product1 = Product {

        name: String::from("لپ تاپ"),

        price: 1200.50,

        quantity: 10,

    };

    product1.quantity = 8;


    let product2 = Product {

        name: String::from("کیبورد"), // مقداردهی صریح نام

        ..product1 // استفاده از struct update syntax برای بقیه فیلدها

    };


    println!("product1: نام: {}, قیمت: {}, تعداد: {}",

             product1.name, product1.price, product1.quantity); // توجه به مالکیت name در product1

    println!("product2: نام: {}, قیمت: {}, تعداد: {}",

             product2.name, product2.price, product2.quantity);

    // ادامه کد در گام های بعدی اضافه خواهد شد

}

```

نکات مهم: Struct Update Syntax داده‌ها را **انتقال می‌دهد** (moves). در مثال بالا، `name` در `product2` صریحاً مقداردهی شده است، بنابراین `String` مربوط به `name` در `product1` به `product2` منتقل نمی‌شود. اما فیلدهای `price` و `quantity` از `product1` به `product2` منتقل می‌شوند. چون `f64` و `u32` انواع `Copy` هستند، انتقال برای آن‌ها به معنی کپی کردن است و `product1` همچنان برای دسترسی به `price` و `quantity` معتبر باقی می‌ماند. اگر فیلدهایی از نوع `String` (که `Copy` نیستند) با `..product1` منتقل می‌شدند و صریحاً در `product2` مقداردهی نمی‌شدند، دیگر نمی‌توانستید به آن فیلدها در `product1` دسترسی پیدا کنید.

**گام 6: تلاش برای چاپ مستقیم و بررسی خطا**

تلاش برای چاپ مستقیم یک نمونه ساختار با استفاده از فرمت `{}` در `println!` منجر به خطا می‌شود.

```

struct Product {

    name: String,

    price: f64,

    quantity: u32,

}


// ... توابع create_product و main از گام های قبلی


fn main() {

    let mut product1 = Product {

        name: String::from("لپ تاپ"),

        price: 1200.50,

        quantity: 10,

    };

    product1.quantity = 8;


    // تلاش برای چاپ مستقیم:

    // println!("My product: {}", product1); // این خط باعث خطا می شود


    // ادامه کد در گام های بعدی اضافه خواهد شد

}

```

خطای دریافتی به صورت زیر خواهد بود:

```

error[E0277]: `Product` doesn't implement `std::fmt::Display`

```

توضیح خطا: ماکروی `println!` با استفاده از `{}` انتظار دارد نوع داده‌ای که می‌خواهد چاپ کند، پیاده‌سازی trait `std::fmt::Display` را داشته باشد. این trait برای نمایش خروجی به کاربر نهایی است. انواع داده اولیه (primitive types) مانند اعداد این trait را به صورت پیش‌فرض پیاده‌سازی کرده‌اند. اما برای ساختارها، نحوه نمایش اطلاعات (مثلاً آیا آکولاد چاپ شود، نام فیلدها چاپ شود، با کاما جدا شوند یا خیر) مبهم است. Rust به صورت پیش‌فرض نمی‌تواند حدس بزند که چگونه یک ساختار را نمایش دهد، بنابراین ساختارها به صورت پیش‌فرض `Display` را پیاده‌سازی نمی‌کنند. پیام خطا به ما می‌گوید که ساختار `Product` این trait را پیاده‌سازی نکرده است.

**گام 7: استفاده از #[derive(Debug)] برای چاپ**

برای چاپ اطلاعات ساختار برای اهداف اشکال‌زدایی (debugging)، می‌توانیم از trait `Debug` استفاده کنیم. برای فعال کردن این قابلیت برای ساختار `Product`، باید ویژگی `#[derive(Debug)]` را قبل از تعریف ساختار اضافه کنیم. سپس می‌توانیم از فرمت‌های `{:?}` یا `{:#?}` در `println!` استفاده کنیم.

```

#[derive(Debug)] // اضافه کردن ویژگی Debug

struct Product {

    name: String,

    price: f64,

    quantity: u32,

}


// ... توابع create_product و main از گام های قبلی


fn main() {

    let mut product1 = Product {

        name: String::from("لپ تاپ"),

        price: 1200.50,

        quantity: 10,

    };

    product1.quantity = 8;


    println!("چاپ دیباگ {:?}: {:?}", product1); // استفاده از فرمت Debug ساده

    println!("چاپ دیباگ {:#?}: {:#?}", product1); // استفاده از فرمت Debug زیبا (pretty-print)

    // ادامه کد در گام های بعدی اضافه خواهد شد

}

```

خروجی چاپ دیباگ به صورت زیر خواهد بود:

```

چاپ دیباگ {:?}: Product { name: "لپ تاپ", price: 1200.5, quantity: 8 }

چاپ دیباگ {:#?}: Product {

    name: "لپ تاپ",

    price: 1200.5,

    quantity: 8,

}

```

نکات مهم: `#[derive(Debug)]` به Rust می‌گوید که پیاده‌سازی پیش‌فرض trait `Debug` را برای این ساختار فراهم کند. فرمت `{:#?}` برای ساختارهای بزرگتر که فیلدهای زیادی دارند، خواناتر است.

**گام 8: استفاده از dbg! برای اشکال‌زدایی**

ماکروی `dbg!` برای اشکال‌زدایی بسیار مفید است. این ماکرو مالکیت یک عبارت (expression) را می‌گیرد، فایل و شماره خطی که در آن فراخوانی شده است، به همراه مقدار حاصل از عبارت را چاپ می‌کند و سپس مالکیت مقدار را برمی‌گرداند. برخلاف `println!`, ماکروی `dbg!` در standard error (stderr) چاپ می‌کند.

```

#[derive(Debug)]

struct Product {

    name: String,

    price: f64,

    quantity: u32,

}


// ... توابع create_product و main از گام های قبلی


fn main() {

    let mut product1 = Product {

        name: String::from("لپ تاپ"),

        price: 1200.50,

        quantity: 10,

    };

    product1.quantity = 8;


    // استفاده از dbg! برای بررسی مقدار quantity

    dbg!(product1.quantity);


    // استفاده از dbg! برای بررسی کل نمونه product1 (نیاز به borrow چون dbg! مالکیت را می گیرد)

    dbg!(&product1);

    // ادامه کد در گام های بعدی اضافه خواهد شد

}

```

خروجی `dbg!` در stderr به صورت زیر خواهد بود:

```

[src/main.rs:XX:YY] product1.quantity = 8 // XX و YY شماره خط و ستون هستند

[src/main.rs:ZZ:WW] &product1 = Product { name: "لپ تاپ", price: 1200.5, quantity: 8 } // ZZ و WW شماره خط و ستون هستند

```

نکات مهم: ماکروی `dbg!` نام فایل و شماره خط را نیز در خروجی خود نشان می‌دهد که در پیدا کردن محل فراخوانی آن بسیار کاربردی است. برای اینکه `dbg!` مالکیت `product1` را نگیرد (چون می‌خواهیم بعداً از آن استفاده کنیم)، یک borrow از آن (`&product1`) را به `dbg!` می‌دهیم.

**گام 9: تعریف بلوک impl**

متدها (methods) و توابع مرتبط (associated functions) در Rust در داخل یک بلوک `impl` (implementation) برای یک ساختار (یا enum یا trait object) تعریف می‌شوند.

```

#[derive(Debug)]

struct Product {

    name: String,

    price: f64,

    quantity: u32,

}


impl Product { // بلوک impl برای ساختار Product

    // متدها و توابع مرتبط در اینجا تعریف خواهند شد

}


fn create_product(name: String, price: f64) -> Product { /* ... */ } // کد از گام 4


fn main() { /* ... */ } // کد از گام 8

```

نکات مهم: تمام آنچه در داخل این بلوک `impl` قرار می‌گیرد، با نوع `Product` مرتبط خواهد بود.

**گام 10: تعریف متد total_price**

متدها مشابه توابع هستند، اما اولین پارامتر آن‌ها همیشه `self` است که نشان‌دهنده نمونه‌ای از ساختار است که متد روی آن فراخوانی می‌شود. برای متدی که فقط داده‌ها را می‌خواند و مالکیت را نمی‌گیرد یا نمونه را تغییر نمی‌دهد، از `&self` به عنوان اولین پارامتر استفاده می‌کنیم. این مخفف `self: &Self` است، که در آن `Self` یک نام مستعار برای نوعی است که بلوک `impl` برای آن است (در اینجا `Product`). برای فراخوانی متد از عملگر نقطه (`.`) پس از نمونه استفاده می‌کنیم.

```

#[derive(Debug)]

struct Product {

    name: String,

    price: f64,

    quantity: u32,

}


impl Product {

    fn total_price(&self) -> f64 { // تعریف متد total_price که immutable borrow می گیرد

        self.price * (self.quantity as f64) // دسترسی به فیلدها با self.fieldName

    }

    // متدهای دیگر در اینجا اضافه خواهند شد

}


// ... توابع create_product و main از گام های قبلی


fn main() {

    let mut product1 = Product {

        name: String::from("لپ تاپ"),

        price: 1200.50,

        quantity: 10,

    };

    product1.quantity = 8;


    // ... چاپ های قبلی


    let total = product1.total_price(); // فراخوانی متد total_price روی نمونه product1

    println!("قیمت کل محصول '{}': {}", product1.name, total);

    // ادامه کد در گام های بعدی اضافه خواهد شد

}

```

نکات مهم: استفاده از `&self` به این معنی است که متد یک borrow غیرقابل تغییر از نمونه را می‌گیرد و مالکیت آن را نمی‌گیرد. این اجازه می‌دهد تا نمونه `product1` پس از فراخوانی متد همچنان در `main` قابل استفاده باشد. برای انجام عملیات ریاضی روی `u32` و `f64`، باید یکی از آن‌ها را به نوع دیگری تبدیل کنیم (اینجا `quantity` را به `f64` تبدیل کردیم).

**گام 11: تعریف متد increase_quantity**

اگر متد نیاز به تغییر نمونه‌ای داشته باشد که روی آن فراخوانی می‌شود، باید یک mutable borrow از نمونه را به عنوان اولین پارامتر دریافت کند، یعنی از `&mut self` استفاده کند.

```

#[derive(Debug)]

struct Product {

    name: String,

    price: f64,

    quantity: u32,

}


impl Product {

    fn total_price(&self) -> f64 { /* ... */ }


    fn increase_quantity(&mut self, amount: u32) { // تعریف متد increase_quantity که mutable borrow می گیرد

        self.quantity += amount; // تغییر فیلد quantity با دسترسی mut

    }

    // تابع مرتبط در اینجا اضافه خواهد شد

}


// ... توابع create_product و main از گام های قبلی


fn main() {

    let mut product1 = Product {

        name: String::from("لپ تاپ"),

        price: 1200.50,

        quantity: 10,

    };

    product1.quantity = 8;


    // ... چاپ قیمت کل


    println!("تعداد قبل از افزایش: {}", product1.quantity);

    product1.increase_quantity(5); // فراخوانی متد increase_quantity

    println!("تعداد بعد از افزایش: {}", product1.quantity);


    // چاپ نمونه تغییر یافته با فرمت دیباگ

    println!("product1 بعد از افزایش تعداد: {:?}", product1);

    // ادامه کد در گام های بعدی اضافه خواهد شد

}

```

نکات مهم: استفاده از `&mut self` به این معنی است که متد می‌تواند داده‌های درون نمونه را تغییر دهد. برای اینکه بتوانیم این متد را فراخوانی کنیم، نمونه‌ای که متد روی آن فراخوانی می‌شود (`product1`) باید قابل تغییر (mutable) باشد، که در گام 3 آن را انجام دادیم.

**گام 12: تعریف تابع مرتبط new**

توابع مرتبط (associated functions) توابعی هستند که در داخل بلوک `impl` برای یک نوع تعریف می‌شوند اما اولین پارامتر آن‌ها `self` نیست. این توابع اغلب برای ایجاد نمونه‌های جدید از نوع (به عنوان سازنده یا constructor) استفاده می‌شوند. یک نام رایج برای این نوع تابع `new` است، اما این نام در زبان Rust ویژه نیست. برای فراخوانی یک تابع مرتبط، از عملگر دابل کالن (`::`) با نام ساختار استفاده می‌کنیم.

```

#[derive(Debug)]

struct Product {

    name: String,

    price: f64,

    quantity: u32,

}


impl Product {

    fn total_price(&self) -> f64 { /* ... */ }

    fn increase_quantity(&mut self, amount: u32) { /* ... */ }


    fn new(name: String, price: f64, quantity: u32) -> Self { // تعریف تابع مرتبط new

        Self { // استفاده از Self به عنوان نام مستعار برای Product

            name, // field init shorthand

            price, // field init shorthand

            quantity, // field init shorthand

        }

    }

}


fn create_product(name: String, price: f64) -> Product { /* ... */ } // کد از گام 4


fn main() {

    let mut product1 = Product { /* ... */ }; // کد از گام 11


    // ... فراخوانی متدها و چاپ ها


    let product3 = Product::new(String::from("مانیتور"), 350.0, 5); // فراخوانی تابع مرتبط new

    println!("product3 با استفاده از تابع new: {:?}", product3);

}

```

نکات مهم: در داخل بلوک `impl`، کلمه کلیدی `Self` یک نام مستعار برای نوعی است که بلوک `impl` برای آن تعریف شده است (در این مورد `Product`). این باعث می‌شود کد عمومی‌تر باشد اگر نوع ساختار بعداً تغییر کند. استفاده از `::` برای فراخوانی تابع مرتبط، نشان می‌دهد که تابع `new` در فضای نام (namespace) ساختار `Product` قرار دارد.

**یادآوری: انواع دیگر ساختارها**

منابع به دو نوع دیگر از ساختارها نیز اشاره دارند که ممکن است در سناریوهای دیگر مفید باشند:

***Tuple Structs:** این ساختارها شبیه تاپل‌ها هستند اما یک نام کلی برای کل ساختار دارند. فیلدها نام ندارند و فقط بر اساس نوع مشخص می‌شوند. این‌ها زمانی مفیدند که می‌خواهید به یک تاپل نام معنادار بدهید و آن را به یک نوع داده جدید تبدیل کنید، اما نیازی به نام‌گذاری هر فیلد ندارید. مانند: `struct Color(i32, i32, i32);`. برای دسترسی به فیلدها از ایندکس (مانند `.0`) استفاده می‌شود.

***Unit-Like Structs:** این ساختارها هیچ فیلدی ندارند و شبیه به واحد نوع `()` هستند. آن‌ها زمانی مفیدند که نیاز دارید یک trait (ویژگی یا رفتار) را روی یک نوع پیاده‌سازی کنید اما هیچ داده‌ای برای ذخیره در آن نوع ندارید. مانند: `struct AlwaysEqual;`.

**یادآوری: مالکیت و Lifetimes در ساختارها**

در تعریف ساختار `Product`، ما از `String` برای فیلد `name` استفاده کردیم. این انتخاب آگاهانه است زیرا می‌خواهیم هر نمونه از ساختار `Product` مالک تمام داده‌های خود باشد و این داده‌ها تا زمانی که خود ساختار معتبر است، معتبر باقی بمانند.

می‌توان ساختارهایی تعریف کرد که شامل ارجاع‌ها (references) به داده‌هایی باشند که توسط چیز دیگری مالکیت می‌شوند (مانند `&str` به جای `String`). اما انجام این کار نیاز به استفاده از *Lifetimes* دارد که Rust تضمین کند ارجاع‌ها در ساختار برای مدت زمان معتبر بودن ساختار، معتبر باقی می‌مانند. تلاش برای ذخیره ارجاع بدون مشخص کردن Lifetimes منجر به خطای کامپایلر می‌شود. منابع اشاره می‌کنند که Lifetimes در فصل 10 بحث خواهند شد و در حال حاضر برای جلوگیری از این خطاها، بهتر است از انواع داده‌ای با مالکیت (مانند `String`) به جای ارجاع‌ها (مانند `&str`) در ساختارها استفاده شود.

**نکات مهم کلی**

ساختارها به شما امکان می‌دهند انواع سفارشی ایجاد کنید که برای دامنه مسئله شما معنادار هستند. با استفاده از ساختارها، می‌توانید قطعات مرتبط داده را کنار هم نگه دارید و هر قطعه را نام‌گذاری کنید تا کد شما واضح‌تر شود. در بلوک‌های `impl` می‌توانید توابعی را تعریف کنید که با نوع شما مرتبط هستند، و متدها نوعی تابع مرتبط هستند که به شما امکان می‌دهند رفتاری را که نمونه‌های ساختار شما دارند، مشخص کنید. ساختارها و enums (که در فصل 6 بحث می‌شوند) سنگ بنای ایجاد انواع جدید در دامنه برنامه شما هستند تا از بررسی نوع در زمان کامپایل Rust حداکثر استفاده را ببرید.

این پاسخ، تکلیف ارائه شده را پیاده‌سازی می‌کند و مهمترین نکات مربوط به ساختارها، فیلدها، نمونه‌ها، قابلیت تغییر، نحوهای Field Init Shorthand و Struct Update، چاپ دیباگ، ماکروی `dbg!`، بلوک‌های `impl`، متدها (`&self`, `&mut self`) و توابع مرتبط (سازنده‌ها با `::`) را بر اساس منابع توضیح می‌دهد.
