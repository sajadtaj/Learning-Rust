**بخش تکلیف**

موضوع اصلی: مدیریت اطلاعات محصول با استفاده از ساختارها و متدها در Rust

شما در حال توسعه یک سیستم ساده برای مدیریت اطلاعات محصولات در یک فروشگاه هستید. برای این کار، نیاز دارید که اطلاعات مربوط به هر محصول (مانند نام، قیمت و تعداد موجودی) را در یک واحد معنادار گروه بندی کنید و عملیاتی را روی این اطلاعات انجام دهید. ساختارها (structs) در Rust ابزار مناسبی برای این کار هستند.

دستورالعمل تکلیف:

لطفاً یک برنامه Rust بنویسید که وظایف زیر را انجام دهد:

1. **تعریف ساختار (Struct Definition):** یک ساختار (struct) با نام `Product` تعریف کنید. این ساختار باید دارای فیلدهای (fields) زیر باشد:
   * `name`: از نوع `String` برای نگهداری نام محصول.
   * `price`: از نوع `f64` برای نگهداری قیمت واحد محصول.
   * `quantity`: از نوع `u32` برای نگهداری تعداد موجودی محصول.
2. **ایجاد نمونه (Instance Creation):** در تابع `main`، یک نمونه (instance) از ساختار `Product` برای یک محصول فرضی (مثلاً "لپ تاپ" با قیمت 1200.50 و تعداد 10) ایجاد کنید.
3. **تغییر مقادیر (Changing Values):** نمونه محصول ایجاد شده در مرحله قبل را قابل تغییر (mutable) کنید و تعداد موجودی آن را به 8 تغییر دهید.
4. **تابع سازنده با Field Init Shorthand:** یک تابع با نام `create_product` خارج از تابع `main` بنویسید که دو پارامتر `name: String` و `price: f64` را دریافت کند. این تابع باید یک نمونه `Product` جدید با مقدار `quantity` اولیه 1 را برگرداند. از قابلیت Field Init Shorthand در Rust برای مختصر کردن کد در این تابع استفاده کنید.
5. **ساخت نمونه جدید با Struct Update Syntax:** در تابع `main`، با استفاده از Struct Update Syntax، یک نمونه جدید از `Product` با نام `product2` ایجاد کنید که تمام اطلاعات آن (نام، قیمت، تعداد موجودی) را از نمونه `product1` (ایجاد شده در مراحل 2 و 3) به ارث ببرد، فقط با این تفاوت که نام محصول در `product2` باید "کیبورد" باشد.
6. **تلاش برای چاپ مستقیم و بررسی خطا (Attempting Direct Print and Examining Error):** سعی کنید نمونه `product1` را مستقیماً با استفاده از `println!("My product: {}", product1);` چاپ کنید. کد را کامپایل و اجرا کنید، خطای دریافتی را مشاهده و یادداشت کنید و توضیح دهید که چرا این خطا رخ می‌دهد.
7. **استفاده از #[derive(Debug)] برای چاپ (Using #[derive(Debug)] for Printing):** به تعریف ساختار `Product` ویژگی (attribute) `#[derive(Debug)]` را اضافه کنید. سپس نمونه `product1` را با استفاده از فرمت‌های دیباگ `{:?}` و `{#?}` در `println!` چاپ کنید. خروجی‌های هر دو فرمت را نشان دهید.
8. **استفاده از dbg! برای اشکال‌زدایی (Using dbg! for Debugging):** از ماکرو `dbg!` برای چاپ کردن مقدار یکی از فیلدهای نمونه `product1` (مثلاً `quantity`) و همچنین خود نمونه `product1` در حین اجرا استفاده کنید.
9. **تعریف بلوک impl (Defining an impl Block):** یک بلوک `impl` برای ساختار `Product` تعریف کنید.
10. **تعریف متد total_price (Defining a total_price Method):** در بلوک `impl` تعریف شده در مرحله 9، یک متد (method) با نام `total_price` تعریف کنید. این متد باید یک immutable borrow از نمونه `Product` (با استفاده از `&self`) را به عنوان پارامتر اول دریافت کند و قیمت کلی محصول (قیمت واحد ضربدر تعداد موجودی) را به عنوان `f64` برگرداند. این متد را برای نمونه `product1` در `main` فراخوانی کرده و نتیجه را چاپ کنید.
11. **تعریف متد increase_quantity (Defining an increase_quantity Method):** در بلوک `impl` برای ساختار `Product`، یک متد با نام `increase_quantity` تعریف کنید که یک mutable borrow از نمونه `Product` (با استفاده از `&mut self`) و یک پارامتر `amount: u32` را دریافت کند و مقدار `amount` را به فیلد `quantity` نمونه فعلی اضافه کند. این متد را روی `product1` فراخوانی کرده و سپس نمونه تغییر یافته را چاپ کنید (با استفاده از فرمت دیباگ).
12. **تعریف تابع مرتبط new (Defining an associated function new):** در بلوک `impl` برای ساختار `Product`، یک تابع مرتبط (associated function) با نام `new` تعریف کنید که پارامترهای `name: String`, `price: f64`, `quantity: u32` را دریافت کرده و یک نمونه جدید از `Product` را برگرداند. این تابع باید به عنوان یک سازنده (constructor) برای ساختار `Product` عمل کند. با استفاده از این تابع یک نمونه `Product` جدید با نام `product3` ایجاد کنید.
