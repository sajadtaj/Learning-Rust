> <div dir='rtl'>

**سوال ۱:** اسلایس در Rust چیست و چه هدفی را دنبال می‌کند؟

**پاسخ ۱:**
**اسلایس‌ها** به شما اجازه می‌دهند به جای کل مجموعه، به یک دنباله **پیوسته از عناصر** در یک مجموعه ارجاع دهید. اسلایس نوعی **ارجاع** است، بنابراین  **مالکیت ندارد** . هدف اصلی آن‌ها ارائه راهی برای کار با بخش‌هایی از داده‌ها بدون نیاز به کپی کردن آن‌ها یا نگرانی در مورد مالکیت کامل داده است.

**سوال ۲:** چرا استفاده از ایندکس عددی برای برگرداندن بخشی از یک رشته (مانند کلمه اول) در Rust می‌تواند مشکل‌ساز و مستعد خطا باشد؟

```rust
fn main() {
    let mut s = String::from("hello world");
    let word = first_word(&s); 
    s.clear(); 
}

fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }
    s.len()
}
```

```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    &s[..]
}

```

**پاسخ ۲:**
برگرداندن صرفاً یک **ایندکس عددی** (مانند `usize`) مشکل‌ساز است زیرا ایندکس تنها در بستر `&String` که از آن مشتق شده، معنی‌دار است. از آنجایی که ایندکس یک مقدار **جداگانه** از `String` است،  **تضمینی وجود ندارد که در آینده هنوز معتبر باشد** . برنامه‌ای که از تابع `first_word` برگرداننده ایندکس استفاده می‌کند، می‌تواند بعد از گرفتن ایندکس، محتوای رشته اصلی را تغییر دهد (مثلاً با `s.clear()`). در این صورت، ایندکس ذخیره شده همچنان همان عدد قبلی را دارد (مثلاً ۵)، اما `s` دیگر محتوایی ندارد که بتوان از آن ایندکس به شکل معنی‌داری استفاده کرد، بنابراین  **ایندکس کاملاً نامعتبر می‌شود** . مجبور بودن به نگرانی در مورد  **خارج شدن ایندکس از هماهنگی با داده‌ها** ، کاری **خسته‌کننده و مستعد خطا** است.

**سوال ۳:** تابع `first_word` که ایندکس پایان کلمه را برمی‌گرداند، چگونه (بر اساس Listing 4-7) پیاده‌سازی شده است؟

**پاسخ ۳:**
تابع `first_word` یک ارجاع به `String` (`&String`) به عنوان پارامتر می‌گیرد و یک `usize` برمی‌گرداند. برای بررسی عناصر رشته، ابتدا آن را با استفاده از متد `as_bytes` به یک **آرایه از بایت‌ها** تبدیل می‌کند. سپس با استفاده از `iter().enumerate()` روی آرایه بایت‌ها **پیمایش** می‌کند. متد `enumerate` روی نتیجه `iter` پیچیده می‌شود و هر عنصر را به صورت یک **تاپل** برمی‌گرداند. عنصر اول تاپل **ایندکس** (`i`) و عنصر دوم یک **ارجاع به عنصر** (`&item`) است. درون حلقه `for`، به دنبال بایت معادل فاصله (`b' '`) می‌گردد. اگر فاصله یافت شد، تابع **ایندکس** `i` را برمی‌گرداند. اگر حلقه به پایان برسد و فاصله‌ای یافت نشود، به این معنی است که کل رشته یک کلمه است، بنابراین تابع **طول کل رشته** (`s.len()`) را برمی‌گرداند.

**سوال ۴:** اسلایس رشته (`&str`) چیست، چه چیزی را ذخیره می‌کند و چگونه می‌توان آن را از یک `String` ایجاد کرد؟

**پاسخ ۴:**
یک **اسلایس رشته** (`&str`) یک **ارجاع به بخشی از یک `String`** است. اسلایس‌ها با استفاده از یک **محدوده در داخل کروشه** (`[starting_index..ending_index]`) ایجاد می‌شوند. `starting_index` اولین موقعیت شامل در اسلایس و `ending_index` **یکی بیشتر از آخرین موقعیت** است. به صورت داخلی، ساختار داده اسلایس **موقعیت شروع** و **طول** اسلایس را ذخیره می‌کند. طول برابر است با `ending_index` منهای `starting_index`.

**سوال ۵:** چه کوتاه نویسی‌هایی برای سینتکس محدوده (`..`) هنگام ایجاد اسلایس در Rust وجود دارد؟

**پاسخ ۵:**
با سینتکس محدوده `..` در Rust، اگر می‌خواهید اسلایس از **ایندکس 0** شروع شود، می‌توانید مقدار قبل از دو نقطه را **حذف کنید** (مانند `[..2]` که معادل `[0..2]` است). به همین ترتیب، اگر اسلایس شما شامل **آخرین بایت** `String` باشد، می‌توانید عدد پایانی را **حذف کنید** (مانند `[3..]` که معادل `[3..len]` است، جایی که `len` طول رشته است). همچنین می‌توانید **هر دو مقدار** را حذف کنید تا یک اسلایس از **کل رشته** بگیرید (مانند `[..]` که معادل `[0..len]` است).

**سوال ۶:** چرا بازگرداندن اسلایس (`&str`) از تابع `first_word` (به جای `usize`) مشکل باگ عدم تطابق ایندکس با داده را حل می‌کند و API تمیزتری ارائه می‌دهد؟

**پاسخ ۶:**
زمانی که `first_word` یک اسلایس (`&str`) برمی‌گرداند، ما یک **مقدار واحد** به دست می‌آوریم که  **به داده اصلی گره خورده است** . این مقدار شامل ارجاعی به نقطه شروع اسلایس و تعداد عناصر (طول) است. با استفاده از اسلایس،  **کامپایلر تضمین می‌کند که ارجاع‌ها به `String` معتبر باقی می‌مانند** . این باعث می‌شود **API تابع بسیار تمیزتر** باشد و مرتکب شدن اشتباه سخت‌تر شود. مشکل باگ نمونه‌ای که ایندکس نامعتبر می‌شد (Listing 4-8) با استفاده از نسخه اسلایس `first_word` **غیرممکن** می‌شود و Rust به ما اجازه می‌دهد مشکل کد خود را **بسیار زودتر** (در زمان کامپایل) تشخیص دهیم.

**سوال ۷:** چرا کد نمونه در Listing 4-8 (که از تابع `first_word` برگرداننده ایندکس استفاده می‌کند و سپس رشته را پاک می‌کند) بدون خطا کامپایل می‌شود، اما استفاده از تابع `first_word` برگرداننده اسلایس در شرایط مشابه منجر به خطای کامپایل می‌شود؟ (اشاره به خطای E0502)

**پاسخ ۷:**
در کد با بازگرداندن ایندکس (Listing 4-8)، `word` فقط یک عدد است و  **هیچ ارتباطی با وضعیت `s` ندارد** . بنابراین، فراخوانی `s.clear()` که رشته را تغییر می‌دهد، روی `word` تأثیری نمی‌گذارد و کامپایلر هیچ مشکلی را در این مرحله تشخیص نمی‌دهد. با این حال، استفاده بعدی از `word` با رشته خالی شده، یک باگ منطقی پنهان است.
اما در کد با بازگرداندن اسلایس (Listing 4-10 در منبع شما که بخشی از آن در آمده است)، `word` حاوی یک **ارجاع نامتغیر** به بخشی از `s` است. متد `s.clear()` برای کوتاه کردن `String` نیاز به یک **ارجاع تغییرپذیر** به آن دارد. طبق قوانین Borrowing در Rust، اگر یک ارجاع نامتغیر به چیزی داشته باشیم،  **نمی‌توانیم همزمان یک ارجاع تغییرپذیر نیز داشته باشیم** . از آنجایی که `println!` بعد از فراخوانی `clear` از ارجاع موجود در `word` استفاده می‌کند، ارجاع نامتغیر باید تا آن نقطه فعال بماند. Rust اجازه نمی‌دهد ارجاع تغییرپذیر مورد نیاز `clear` و ارجاع نامتغیر مورد نیاز `word` همزمان وجود داشته باشند، و بنابراین  **کامپایل با خطای E0502 شکست می‌خورد** . این نشان می‌دهد که Rust با استفاده از اسلایس‌ها، یک دسته کامل از خطاها را در زمان کامپایل حذف می‌کند.

**سوال ۸:** لیترال‌های رشته‌ای (String Literals) در Rust مانند `"Hello, world!"` از چه نوعی هستند و چرا تغییرناپذیرند؟

**پاسخ ۸:**
لیترال‌های رشته‌ای (مانند `"Hello, world!"`) در داخل **باینری برنامه** ذخیره می‌شوند.  **نوع لیترال رشته‌ای، `&str` است** . این به این معنی است که لیترال‌های رشته‌ای در واقع همان **اسلایس‌های رشته‌ای** هستند که به نقطه خاصی در باینری اشاره می‌کنند. دلیل **تغییرناپذیر بودن** لیترال‌های رشته‌ای نیز همین است؛ زیرا  **`&str` یک ارجاع نامتغیر است** .

**سوال ۹:** چرا یک برنامه‌نویس باتجربه Rust، تابع `first_word` را طوری تعریف می‌کند که پارامتر آن از نوع `&str` باشد (به جای `&String`)؟

**پاسخ ۹:**
یک برنامه‌نویس باتجربه Rust ترجیح می‌دهد امضای تابع `first_word` را به صورت `fn first_word(s: &str) -> &str` بنویسد. این کار باعث می‌شود **API تابع کلی‌تر و مفیدتر** باشد  **بدون اینکه هیچ عملکردی از دست برود** . دلیل این امر این است که تابعی که پارامتر `&str` می‌گیرد، هم روی **مقادیر `&String`** و هم روی **مقادیر `&str`** کار می‌کند.
اگر یک اسلایس رشته‌ای (`&str`) داشته باشیم، می‌توانیم آن را مستقیماً به تابع پاس دهیم. اگر یک `String` داشته باشیم، می‌توانیم یک **اسلایس از آن `String`** (چه جزئی مانند `&my_string[0..6]` و چه کامل مانند `&my_string[..]`) یا یک **ارجاع به کل `String`** (مانند `&my_string` که معادل یک اسلایس کامل است) را به تابع پاس دهیم. این انعطاف‌پذیری از قابلیتی به نام **Deref Coercions** (اجبار نوع Deref) استفاده می‌کند. بنابراین، استفاده از `&str` در امضای تابع، آن را برای انواع ورودی بیشتری قابل استفاده می‌کند.

**سوال ۱۰:** آیا مفهوم اسلایس فقط محدود به رشته‌هاست یا برای انواع دیگری از مجموعه‌ها نیز کاربرد دارد؟ مثالی بزنید.

**پاسخ ۱۰:**
خیر، مفهوم اسلایس فقط محدود به رشته‌ها نیست و یک **نوع اسلایس کلی‌تر** نیز وجود دارد. این نوع اسلایس برای انواع **مجموعه‌های دیگر** مانند آرایه‌ها نیز کاربرد دارد.
برای مثال، یک آرایه از اعداد صحیح مانند `let a =;` را در نظر بگیرید. می‌توان بخشی از این آرایه را به صورت اسلایس ارجاع داد، مانند `let slice = &a[1..3];`. این اسلایس نوع **`&[i32]`** دارد. این نوع اسلایس‌ها نیز دقیقاً همانند اسلایس‌های رشته‌ای عمل می‌کنند، یعنی یک **ارجاع به عنصر اول** و یک **طول** را ذخیره می‌کنند. این نوع اسلایس برای انواع مجموعه‌ها استفاده می‌شود.

این ۱۰ سوال و پاسخ بر اساس اطلاعات موجود در متن منابع ارائه شده است. امیدوارم برای شما مفید باشد.

</div>
