// دو  راه حل مختلف را برای مدیریت حافظه به کار می‌بردند
// garbage collector
// مدیریت دستی حافظه

// نحوه مدیریت حافظه در راست حق مالکیت می باشد
// بحث مالکیّت  برای ما  
// memory safety 
// را تضمین می‌کند


// Stack و Heap 
// هر دو بخش‌هایی از حافظه هستند که هنگام اجرا در اختیار برنامه قرار می‌گیرند. امّا شیوه‌ی کاری آن‌ها متفاوت است.
// داده‌ها در 
// Stack
//  به صورت 
// first in, last out 
// ذخیره می‌شوند. یعنی آخرین داده‌ای که در 
// Stack
//  قرار می‌گیرد، اوّلین داده‌ای است که از آن خارج می‌شود.

// نحوه‌ی استفاده از 
// Heap 
// متفاوت است و مثل 
// Stack 
// ساخت‌یافته نیست. وقتی که می‌خواهیم داده‌ای را به 
// Heap 
// اضافه کنیم، ابتدا از سیستم عامل درخواست می‌کنیم تا فضایی‌را در اختیارمان قرار بدهد. سیستم عامل هم در جایی از حافظه یک بخش به اندازه‌ی کافی بزرگ‌را جدا می‌کند و یک اشاره‌گر 
// (pointer)
//  به آن فضا را بر می‌گرداند.


// قوانین طلایی مالکیّت

// ۱. برای هر مقدار، یک متغیّر وجود دارد که مالک مالکیت آن مقدار نامیده می‌شود.
// ۲. هر مقدار در یک لحظه تنها می‌تواند یک مالک داشته باشد.
// ۳. وقتی که مالک یک مقدار از اسکپ خارج می‌شود، آن مقدار هم از بین می‌رود.  -> مهم 
// Scop = { هر چیزی که بین دو تا اکولاد هست}

// مالکیت در اینجا از نوع 
// Heapاست


// استترینگ های که از قبل طول اهنها مشخص نیست
// Scope 
// یک مقدار، ناحیه‌ای از کد است که آن مقدار در آن ناحیه معتبر 
// (valid)
//  است. یعنی وقتی از آن بخش از کد خارج می‌شویم دیگر آن مقدار وجود ندارد.

// fn main(){
//     let mut my_string = String::from("یک رشته جدید است");
//     my_string.push_str("که این بخش به انتتهای آن اضافه شده استت");
//     println!("{}",my_string);
// }


// تمامی مقادیر عددی صحیح و اعشاری، مقادیر 
// boolean
// و کاراکترها کپی می‌شوند 
// . به‌علاوه تمامی 
// tupple
// هایی که شامل 
// type
// های بالا می‌شوند هم کپی می‌شوند.
// تمام چیزهایی که باقی‌مانده‌اند 
// move 
// خواهند شد. 
// مگر اینکه به شیوه‌ای که بعداً با هم می‌بینیم 
// به عنوان نوع داده‌ای که قابل کپی شدن است معرفی شوند.


// fn main() {
//     let a = String::from("hello");
//     i_am_owner(a);
//     println!("a in main function: {}", a);
// }
// fn i_am_owner(input: String) {
//     println!("The input value is: {}", input);
// }
// با فراخوانی تابع 
// i_am_owner
// // درون 
// // main
// ما مالکیت متغیر را به تابع جدید دادیم  ودیگر  نمتوانیم در 
// main
// با آن کار کنیم،
// راه حل اینست که دوباره آنرا یرگردانیم
// یعنی تابع زیر 


// همانطوری که فراخوانی یک تابع مالکیّت ورودی‌ها را به آن می‌سپارد، 
// return
// کردن از آن هم مالکیّت داده را به کسی‌ 
// که آن مقدار را می‌گیرد منتقل می‌کند.
fn main() {
    let mut a = String::from("hello");    // نگتته اول
    a = i_am_owner(a);                      //نکته دوم
    println!("a in main function: {}", a);
}
fn i_am_owner(input: String) -> String {    // نکته سوم
    println!("The input value is: {}", input);
    return input;                                   // نکته چهارم
}

// چندتا تغییر داده‌ایم.


// ۱-متغیّر 
// a 
// را 
// mutable
//  کردیم تا بتوانیم دوباره به آن مقدار بدهیم.


// ۲-مقدار متغیّر 
// a
//  را برابر با خروجی تابع 
//  i_am_owner
//   گذاشتیم

// ۳-داخل همین تابع در پایان کار مقدار 
// input
//  را خروجی داده‌ایم


// فرق کپی و موو:
// وقتی کپی میکنیم عین همان مقادیر را در متغیر جدید می ریزد
// وقتی موو میکنیم ادرس اول هیپ فضای آن متغیر را میدهیم و به عبارتی از آن مقادیر دوتا ندارم بلکه یک مقادیر داریم که 
// که دو متغیر متفاپن به ادرس آن اشاره دارند