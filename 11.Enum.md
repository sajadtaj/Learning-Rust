<html dir="rtl">
<!-- </html> -->


# مفاهیم اصلی در Rust: Enumها و تطابق الگو

در زبان Rust، چندین ابزار قدرتمند برای تعریف انواع داده سفارشی و کنترل جریان برنامه بر اساس مقادیر مختلف وجود دارد. Enums به شما این امکان را می‌دهند که نوعی را تعریف کنید که می‌تواند یکی از مجموعه‌ای از حالت‌های ممکن باشد. در کنار آن، تطابق الگو (`match`) و عبارات مختصرتر مانند `if let` و `let else` ابزارهایی برای کار با این Enums و سایر انواع داده فراهم می‌کنند.

## تعریف Enumها
.

در زیان  Rust مفهوم Enum ها روشی برای بیان اینکه یک مقدار، یکی از مجموعه‌ای از مقادیر ممکن است را فراهم می‌کنند.

در حالی که Struct ها راهی برای گروه‌بندی فیلدها و داده‌های مرتبط هستند، Enumها برای حالت‌هایی مناسبند که یک مقدار تنها می‌تواند یکی از چندین حالت مجزا باشد. به عنوان مثال، یک آدرس IP یا نسخه 4 است یا نسخه 6، اما همزمان هر دو نیست. این خاصیت، ساختار داده Enum را مناسب می‌سازد زیرا مقدار یک Enum فقط می‌تواند یکی از واریانت‌های (variants) خود باشد.


### ساختار و استفاده از Enumها

شما می‌توانید یک Enum را با کلمه کلیدی `enum` تعریف کرده و واریانت‌های ممکن آن را فهرست کنید. به عنوان مثال، برای آدرس‌های IP:

```rust
enum IpAddrKind {
    V4,
    V6,
}
```
واریانت‌های Enum تحت شناسه آن نام‌گذاری شده و با دو نقطه دوتایی (`::`) جدا می‌شوند. این باعث می‌شود مقادیری مانند `IpAddrKind::V4` و `IpAddrKind::V6` از یک نوع مشترک باشند: `IpAddrKind`. این امکان را فراهم می‌کند که تابعی تعریف شود که هر نوع `IpAddrKind` را بپذیرد و با هر دو واریانت فراخوانی شود:

```rust
fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;

    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
}

fn route(ip_kind: IpAddrKind) {}
```

### داده‌های مرتبط در Enumها

یک مزیت دیگر Enumها این است که می‌توانند داده‌ها را مستقیماً درون هر واریانت خود قرار دهند. به جای تعریف یک Struct که حاوی یک Enum و داده‌های مرتبط باشد (مانند مثالی با Struct `IpAddr` که فیلدهای `kind` و `address` دارد)، می‌توانید داده‌ها را به واریانت‌های Enum متصل کنید. هر واریانت می‌تواند انواع و مقادیر متفاوتی از داده‌های مرتبط داشته باشد.

مثال آدرس IP با داده‌های مرتبط:

```rust
fn main() {
    // Enum با داده String
    enum IpAddr {
        V4(String),
        V6(String),
    }
    let home = IpAddr::V4(String::from("127.0.0.1"));
    let loopback = IpAddr::V6(String::from("::1"));

    // Enum با انواع مختلف داده
    enum BetterIpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }
    let home_better = BetterIpAddr::V4(127, 0, 0, 1);
    let loopback_better = BetterIpAddr::V6(String::from("::1"));
}
```
نام هر واریانت Enum که تعریف می‌کنید، به تابعی تبدیل می‌شود که نمونه‌ای از Enum را می‌سازد (مانند `IpAddr::V4()` که یک آرگومان `String` می‌گیرد و نمونه‌ای از نوع `IpAddr` برمی‌گرداند).


  در Enumها می‌توانند هر نوع داده‌ای را درون واریانت‌های خود داشته باشند، از جمله Structها یا حتی Enumهای دیگر. مثال `Message` نشان می‌دهد که واریانت‌ها می‌توانند داده‌های مختلفی از جمله بدون داده، فیلدهای نام‌گذاری شده (مانند Struct)، یک مقدار تکی (مانند Tuple Struct) یا چندین مقدار تکی داشته باشند:

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
// این Enum می‌تواند داده‌های مشابهی را با Structهای زیر نگه دارد، اما Enum یک نوع واحد است:
// struct QuitMessage;
// struct MoveMessage { x: i32, y: i32, }
// struct WriteMessage(String);
// struct ChangeColorMessage(i32, i32, i32);
```
مشابه Structها، می‌توانید متدها را با استفاده از `impl` روی Enumها نیز تعریف کنید.

## Enum استاندارد Option<T> و مزایای آن نسبت به مقادیر Null

یکی از Enumهای بسیار متداول و مفید در کتابخانه استاندارد Rust، Enum به نام `Option` است. نوع `Option` سناریوی بسیار رایجی را کدگذاری می‌کند که در آن یک مقدار می‌تواند "چیزی" باشد یا "هیچ" نباشد. مثلاً، درخواست اولین آیتم از یک لیست خالی "هیچ" (nothing) را برمی‌گرداند.

### مشکل مقادیر Null

برخلاف بسیاری از زبان‌های برنامه‌نویسی دیگر، Rust ویژگی **null** را ندارد. در زبان‌هایی با null، متغیرها می‌توانند همیشه در یکی از دو حالت باشند: null یا not-null (غیر تهی). همانطور که تونی هور (Tony Hoare)، مخترع null، آن را "اشتباه یک میلیارد دلاری" نامید، مشکل null این است که اگر سعی کنید از یک مقدار null به عنوان یک مقدار not-null استفاده کنید، با خطا مواجه خواهید شد. چون این خاصیت null یا not-null بودن در همه جا وجود دارد، ارتکاب این نوع خطا بسیار آسان است.

### راه حل Rust: Option<T>

در Rust برای بیان مفهوم "مقدار نامعتبر یا غایب" (invalid or absent value) از Enum به نام `Option<T>` استفاده می‌کند که در کتابخانه استاندارد تعریف شده است:

```rust
enum Option<T> {
    None, // نماینده "هیچ"
    Some(T), // نماینده "چیزی" با داده T
}
```
 این Enum آنقدر مفید است که حتی در پیش‌درآمد (prelude) زبان (مجموعه‌ای از موارد که به صورت خودکار در هر برنامه Rust وارد می‌شوند) گنجانده شده است. واریانت‌های آن، `Some` و `None`، نیز مستقیماً بدون پیشوند `Option::` قابل استفاده هستند.

  آ `<T>` یک پارامتر نوع جنریک (generic type parameter) است که به این معنی است که واریانت `Some` می‌تواند یک قطعه داده از *هر نوعی* را در خود نگه دارد. هر نوع مشخص که به جای `T` استفاده شود، نوع کلی `Option<T>` را به یک نوع متفاوت تبدیل می‌کند (مانند `Option<i32>` یا `Option<char>`). اگر یک مقدار در `Some` مشخص شود، Rust می‌تواند نوع را استنتاج کند، اما برای `None`، شما باید نوع `Option` کلی را با توضیح نوع (type annotation) مشخص کنید.

**چرا `Option<T>` بهتر از null است؟**

دلیل اصلی این است که `Option<T>` و `T` انواع متفاوتی هستند. **کامپایلر Rust به شما اجازه نمی‌دهد که از یک مقدار `Option<T>` طوری استفاده کنید که گویی قطعاً یک مقدار معتبر از نوع `T` است.** برای استفاده از مقدار `T` درون یک `Some`، باید صراحتاً `Option<T>` را به `T` تبدیل کنید. این به کامپایلر امکان می‌دهد تا شما را مجبور کند که حالت `None` (عدم وجود مقدار) را صراحتاً مدیریت کنید. این کار از اشتباه رایج فرض بر عدم null بودن مقداری که در واقع ممکن است null باشد، جلوگیری می‌کند.

نمونه کدی که کامپایل نمی‌شود:

```rust
fn main() {
    let x: i8 = 5;
    let y: Option<i8> = Some(5);

    // let sum = x + y; // این خط باعث خطا می‌شود
}
```
**نکات کلیدی خطای اجرا:**
خروجی کامپایلر شامل خطایی مشابه این است:
```
error[E0277]: cannot add `Option<i8>` to `i8`
...
| ^ no implementation for `i8 + Option<i8>`
...
= help: the trait `Add<Option<i8>>` is not implemented for `i8`
```
این پیام خطا به طور مؤثری می‌گوید که Rust نمی‌داند چگونه یک `i8` را با یک `Option<i8>` جمع کند، **چون آنها انواع متفاوتی هستند.** وقتی در Rust مقداری از نوعی مانند `i8` دارید که `Option` نیست، کامپایلر تضمین می‌کند که شما همیشه یک مقدار معتبر دارید. اما وقتی یک `Option<i8>` دارید، باید نگران احتمال عدم وجود مقدار باشید، و کامپایلر مطمئن می‌شود که شما آن حالت را قبل از استفاده از مقدار مدیریت کنید. این تصمیم طراحی عامدانه Rust بود تا گسترش null را محدود کرده و ایمنی کد را افزایش دهد.

برای استخراج مقدار `T` از یک واریانت `Some`، `Option<T>` متدهای مفیدی دارد، اما رایج‌ترین راه برای کار با مقادیر `Option<T>` استفاده از **تطابق الگو** است.

## تطابق الگو با Construct کنترل جریان match

آRust یک Construct کنترل جریان فوق‌العاده قدرتمند به نام `match` دارد که به شما امکان می‌دهد یک مقدار را در برابر مجموعه‌ای از الگوها مقایسه کرده و سپس کدی را بر اساس الگوی منطبق اجرا کنید. قدرت `match` از بیانی بودن الگوها و این واقعیت ناشی می‌شود که کامپایلر تأیید می‌کند که تمام حالت‌های ممکن مدیریت شده‌اند (exhaustiveness).

می‌توانید `match` را مانند یک دستگاه مرتب‌سازی سکه تصور کنید: سکه‌ها روی یک مسیر با سوراخ‌هایی با اندازه‌های مختلف می‌لغزند، و هر سکه در اولین سوراخی که اندازه آن با آن مطابقت دارد، می‌افتد. به همین ترتیب، مقادیر در `match` از هر الگو عبور می‌کنند و در اولین الگویی که مقدار با آن مطابقت دارد ("جا می‌شود")، مقدار به بلوک کد مرتبط می‌افتد تا در طول اجرا استفاده شود.

### ساختار و استفاده از match

مثال سکه:

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin { // match روی مقدار coin
        Coin::Penny => 1, // بازوی match با الگوی Coin::Penny و کد 1
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```
آ`match` با کلمه کلیدی `match` و سپس یک عبارت شروع می‌شود (در اینجا مقدار `coin`). برخلاف `if` که نیاز به عبارت بولی دارد، `match` می‌تواند روی هر نوعی کار کند. سپس بازوهای `match` می‌آیند؛ هر بازو شامل یک الگو و کدی است که با `=>` جدا می‌شوند. وقتی `match` اجرا می‌شود، مقدار را به ترتیب با الگوی هر بازو مقایسه می‌کند. اگر الگویی منطبق باشد، کد مرتبط اجرا می‌شود. کد مرتبط با هر بازو یک عبارت است و مقدار حاصل از آن، مقدار بازگشتی کل عبارت `match` است.

اگر کد بازوی `match` کوتاه باشد (مانند بازگرداندن یک مقدار)، از کروشه `{}` استفاده نمی‌شود. برای اجرای چندین خط کد در یک بازو، باید از کروشه استفاده کنید، و کامای بعد از آن بازو اختیاری است. مثال بازوی match چند خطی:

```rust
match coin {
    Coin::Penny => { // استفاده از کروشه برای چند خط کد
        println!("Lucky penny!");
        1 // مقدار بازگشتی بازو
    }
    // ... سایر بازوها
}
```

### الگوهایی که به مقادیر متصل می‌شوند (Pattern Binding)

بازوهای `match` می‌توانند به بخش‌هایی از مقادیری که با الگو مطابقت دارند، متصل شوند. اینگونه می‌توانیم مقادیر را از واریانت‌های Enum استخراج کنیم.

مثال سکه با داده مرتبط:

```rust
#[derive(Debug)] // برای نمایش مقدار UsState
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState), // واریانت Quarter حاوی داده UsState
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => { // الگوی Coin::Quarter(state) مقدار UsState را به متغیر state متصل می‌کند
            println!("State quarter from {state:?}!");
            25
        }
    }
}

fn main() {
    value_in_cents(Coin::Quarter(UsState::Alaska)); // مثال فراخوانی
}
```
در این مثال، الگوی `Coin::Quarter(state)` با یک مقدار `Coin::Quarter` مطابقت دارد و مقدار `UsState` درون آن واریانت به متغیر `state` متصل می‌شود. سپس می‌توان از متغیر `state` در کد آن بازو استفاده کرد.

### تطابق با Option<T>

می‌توانید `Option<T>` را نیز با `match` مدیریت کنید. مثال تابعی که اگر مقدار وجود داشته باشد به آن 1 اضافه می‌کند:

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None, // اگر مقدار None باشد، None برگردانده می‌شود
        Some(i) => Some(i + 1), // اگر مقدار Some(i) باشد، i به مقدار درون Some متصل شده و Some(i + 1) برگردانده می‌شود
    }
}

fn main() {
    let five = Some(5);
    let six = plus_one(five); // six می‌شود Some(6)
    let none = plus_one(None); // none می‌شود None
}
```
اجرای `plus_one(Some(5))`: مقدار `x` برابر `Some(5)` است. این مقدار با الگوی `None` مطابقت ندارد. با الگوی `Some(i)` مطابقت دارد. متغیر `i` به مقدار 5 متصل می‌شود. کد `Some(i + 1)` اجرا شده و `Some(6)` برگردانده می‌شود.
اجرای `plus_one(None)`: مقدار `x` برابر `None` است. این مقدار با الگوی `None` مطابقت دارد. کد `None` اجرا شده و `None` برگردانده می‌شود.

### match ها جامع (Exhaustive) هستند

یکی از جنبه‌های مهم `match` این است که الگوهای بازوها **باید تمام حالت‌های ممکن** را پوشش دهند. اگر یک حالت پوشش داده نشود، کد کامپایل نخواهد شد.

مثال تابع `plus_one` بدون مدیریت حالت `None`:

```rust
fn main() {
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            Some(i) => Some(i + 1),
            // حالت None اینجا پوشش داده نشده است!
        }
    }
    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
}
```
**نکات کلیدی خطای اجرا:**
تلاش برای کامپایل این کد منجر به خطای زیر می‌شود:
```
error[E0004]: non-exhaustive patterns: `None` not covered
--> src/main.rs:3:15
|
3 | match x {
| ^ pattern `None` not covered
...
= note: the matched value is of type `Option<i32>`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
```
این خطا به وضوح بیان می‌کند که الگوها جامع نیستند (`non-exhaustive patterns`) و حالت `None` پوشش داده نشده است. Rust می‌داند که ما تمام حالت‌های ممکن را پوشش نداده‌ایم. **Matchها در Rust جامع هستند:** برای معتبر بودن کد، باید هر امکان را مدیریت کنیم. به‌ویژه در مورد `Option<T>`، با جلوگیری از فراموشی مدیریت صریح حالت `None`، Rust ما را از فرض بر وجود مقدار در حالی که ممکن است null باشد، محافظت کرده و "اشتباه یک میلیارد دلاری" را غیرممکن می‌سازد.

### الگوهای فراگیر (Catch-All) و جایگزین `_`

شما می‌توانید برای چند مقدار خاص عملیات ویژه‌ای انجام دهید، اما برای سایر مقادیر یک عمل پیش‌فرض واحد در نظر بگیرید. الگوهای فراگیر این کار را انجام می‌دهند.

مثال تاس:

```rust
fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        other => move_player(other), // الگوی فراگیر: هر مقدار دیگری به متغیر other متصل می‌شود
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
}
```
الگوی `other` با تمام مقادیری که قبلاً به صراحت فهرست نشده‌اند مطابقت دارد. این الگوی فراگیر، requirement جامع بودن `match` را برآورده می‌کند. **مهم است که الگوی فراگیر را در انتها قرار دهید**، زیرا الگوها به ترتیب ارزیابی می‌شوند؛ اگر الگوی فراگیر زودتر باشد، بازوهای بعدی هرگز اجرا نمی‌شوند، و Rust به شما هشدار خواهد داد.

آRust همچنین الگوی خاصی به نام `_` دارد که با هر مقداری مطابقت دارد اما به آن مقدار متصل نمی‌شود. این به Rust می‌گوید که ما قصد استفاده از مقدار در الگوی فراگیر را نداریم، بنابراین Rust در مورد متغیر استفاده نشده (unused variable) هشدار نخواهد داد.

استفاده از `_` به جای متغیر:

```rust
fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => reroll(), // الگوی فراگیر _ که به مقدار متصل نمی‌شود
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
}
```
این مثال نیز شرط جامع بودن را برآورده می‌کند، زیرا ما به صراحت تمام مقادیری که با الگوهای قبلی مطابقت ندارند را نادیده می‌گیریم. اگر نمی‌خواهید کدی برای حالت فراگیر اجرا شود، می‌توانید از واحد مقدار `()` (tuple خالی) به عنوان کد بازو استفاده کنید:

```rust
fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => (), // هیچ کاری انجام نمی‌دهد
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
}
```
این نشان می‌دهد که ما قصد استفاده از هیچ مقدار دیگری را نداریم و نمی‌خواهیم کدی در این حالت اجرا کنیم.

## کنترل جریان مختصر با if let و let else

در مواقعی که یک عبارت `match` برای مدیریت تنها یک حالت از یک Enum یا `Option` کمی طولانی به نظر می‌رسد، Rust Constructهای مختصرتری به نام `if let` و `let else` ارائه می‌دهد.

### if let

آSyntax `if let` به شما امکان می‌دهد `if` و `let` را ترکیب کنید تا راهی کم‌حجم‌تر برای مدیریت مقادیری که با یک الگو مطابقت دارند، در حالی که بقیه را نادیده می‌گیرند، داشته باشید.

مقایسه `match` و `if let` برای `Option<u8>`:

```rust

fn main() {
    // استفاده از match (Listing 6-6)
    let config_max = Some(3u8);
    match config_max {
        Some(max) => println!("The maximum is configured to be {max}"),
        _ => (), // کد boilerplate برای نادیده گرفتن حالت None
    }
}

// استفاده از if let (رفتار مشابه)
fn main() {
    let config_max = Some(3u8);
    if let Some(max) = config_max { // الگوی Some(max) روی مقدار config_max
        println!("The maximum is configured to be {max}"); // این بلوک فقط اگر match موفق باشد اجرا می‌شود
    }
}

```

آsyntax `if let` یک الگو و یک عبارت را با علامت مساوی `=` می‌گیرد. اگر مقدار عبارت با الگو مطابقت داشته باشد، کد در بلوک `if let` اجرا می‌شود. در مثال بالا، الگوی `Some(max)` است و `max` به مقدار درون `Some` متصل می‌شود.

استفاده از `if let` به معنی تایپ کمتر، تورفتگی کمتر و کد boilerplate کمتر است. **اما شما جامع بودن (exhaustive checking) را که `match` تضمین می‌کند، از دست می‌دهید.** انتخاب بین `match` و `if let` بستگی به موقعیت خاص شما و اینکه آیا مختصر بودن در مقابل از دست دادن جامع بودن، معامله مناسبی است یا خیر، دارد.

شما می‌توانید `if let` را به عنوان syntax sugar (شکلی کوتاه‌تر و خواناتر از syntaxی پیچیده‌تر) برای یک `match` در نظر بگیرید که کدی را اجرا می‌کند وقتی مقدار با یک الگو مطابقت دارد و سپس تمام مقادیر دیگر را نادیده می‌گیرد.

آ`if let` می‌تواند یک بلوک `else` نیز داشته باشد. بلوک کد `else` همانند بلوک کدی است که در حالت `_` در عبارت `match` معادل آن قرار می‌گرفت.

مثال `if let` با `else` برای `Coin`:

```rust
#[derive(Debug)]
enum UsState { Alabama, Alaska, /* --snip-- */ }
enum Coin { Penny, Nickel, Dime, Quarter(UsState), }

fn main() {
    let coin = Coin::Penny;
    let mut count = 0;

    // استفاده از if let با else
    if let Coin::Quarter(state) = coin { // اگر سکه Quarter باشد
        println!("State quarter from {state:?}!"); // این کد اجرا می‌شود
    } else { // در غیر این صورت (اگر Penny, Nickel, یا Dime باشد)
        count += 1; // این کد اجرا می‌شود (مانند _ => count += 1 در match)
    }
}
```

### let...else

یکی از الگوهای رایج این است که وقتی یک مقدار وجود دارد، محاسباتی انجام شود و در غیر این صورت یک مقدار پیش‌فرض برگردانده شود یا از تابع خارج شود. در سناریوهایی که استفاده از `if let` برای استخراج مقدار و سپس ادامه کار ممکن است باعث تورفتگی زیاد یا پیچیدگی در جریان برنامه شود (مثال‌های Listings 6-7 و 6-8)، Rust Construct جدید `let...else` را برای زیباتر بیان کردن این الگو ارائه می‌دهد.

آSyntax `let...else` در سمت چپ یک الگو و در سمت راست یک عبارت می‌گیرد، شبیه به `if let`. **اما `let...else` بلوک `if` ندارد، تنها یک بلوک `else` دارد.**

**نحوه کار `let...else`:**
*   اگر الگو مطابقت داشته باشد، مقدار از الگو در **اسکوپ بیرونی** متصل می‌شود. سپس برنامه به اجرای کد بعد از عبارت `let else` ادامه می‌دهد ("مسیر خوش" یا happy path).
*   اگر الگو مطابقت *نکند*، برنامه به بلوک `else` وارد می‌شود. **بلوک `else` حتماً باید جریان کنترل را متوقف کند**، معمولاً با برگرداندن از تابع (`return`)، اجرای `panic!` یا فراخوانی یک تابع غیر بازگشتی (diverging function).

مثال `describe_state_quarter` با استفاده از `let else`:

```rust
#[derive(Debug)]
enum UsState { Alabama, Alaska, /* --snip-- */ }

impl UsState {
    fn existed_in(&self, year: u16) -> bool {
        match self {
            UsState::Alabama => year >= 1819,
            UsState::Alaska => year >= 1959,
            // -- snip --
        }
    }
}

enum Coin { Penny, Nickel, Dime, Quarter(UsState), }

fn describe_state_quarter(coin: Coin) -> Option<String> {
    let Coin::Quarter(state) = coin else { // اگر coin با الگوی Quarter(state) مطابقت نکند
        return None; // بلوک else اجرا شده و از تابع خارج می‌شود
    }; // اگر مطابقت کند، state در اسکوپ بیرونی (بعد از let else) قابل استفاده است

    // این کد در "مسیر خوش" قرار دارد و فقط زمانی اجرا می‌شود که state با موفقیت استخراج شده باشد
    if state.existed_in(1900) {
        Some(format!("{state:?} is pretty old, for America!"))
    } else {
        Some(format!("{state:?} is relatively new."))
    }
}

fn main() {
    if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {
        println!("{desc}");
    }
}
```
با استفاده از `let else`، کد اصلی تابع (بررسی قدمت state) در بدنه اصلی تابع باقی می‌ماند و جریان کنترل در صورت عدم مطابقت الگو به وضوح در بلوک `else` مدیریت می‌شود. این باعث می‌شود فهمیدن اینکه چگونه بخش‌های مختلف تابع به هم مرتبط هستند، آسان‌تر شود.

**خلاصه:**
اگر موقعیتی دارید که منطق برنامه شما برای بیان با یک `match` بسیار پرحجم است، به یاد داشته باشید که `if let` و `let...else` نیز به عنوان ابزارهایی در جعبه ابزار Rust شما قرار دارند.

این ابزارها به شما کمک می‌کنند تا مفهوم‌ها را در دامنه خود با استفاده از انواع سفارشی (Structs و Enums) بیان کنید و از طریق سیستم نوع (type system) Rust، ایمنی نوع (type safety) را تضمین کنید.


</html>