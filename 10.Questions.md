
## سوالات کلیدی در مورد استراکت‌ها در Rust

این بخش شامل سوالاتی است که به عمق مفاهیم و جزئیات کار با استراکت‌ها می‌پردازد.

### بخش: مبانی و مقایسه

1.  **سوال:** فرق اصلی بین استفاده از متغیرهای تکی، تاپل‌ها (tuples)، و استراکت‌ها (structs) برای گروه‌بندی داده‌های مرتبط (مانند ابعاد مستطیل) چیست؟ چرا استراکت‌ها در مقایسه با دو روش دیگر در این زمینه شفافیت و قابلیت مدیریت بیشتری ارائه می‌دهند؟
    **پاسخ:** استفاده از متغیرهای تکی مانند `width1` و `height1` در تابعی مثل `area(width, height)` این مشکل را دارد که مشخص نیست پارامترها به هم مرتبط هستند و مربوط به یک موجودیت (مانند یک مستطیل) می‌شوند. با استفاده از تاپل‌ها، می‌توان داده‌های مرتبط (مثل ابعاد مستطیل) را در یک موجودیت واحد (`(30, 50)`) گروه‌بندی کرد و تنها یک آرگومان را به تابع پاس داد. اما تاپل‌ها به عناصر خود نامی نمی‌دهند و برای دسترسی به مقادیر باید از ایندکس عددی (مثل `dimensions.0` و `dimensions.1`) استفاده کرد. این باعث می‌شود خوانایی کد کمتر شده و مشخص نباشد که ایندکس 0 مربوط به عرض است یا ارتفاع، که می‌تواند منجر به خطا شود، به خصوص اگر ترتیب را اشتباه وارد کنیم. **استراکت‌ها (structs)** با افزودن نام به هر قطعه داده (فیلد)، این مشکل شفافیت را حل می‌کنند. در استراکت، هر فیلد نام مشخصی دارد (مثل `width` و `height`) که معنی آن داده را مشخص می‌کند. این نام‌گذاری باعث می‌شود **کد خواناتر و قابل مدیریت‌تر باشد** و هنگام دسترسی به مقادیر (مثلاً `rectangle.width`) یا هنگام ایجاد نمونه (instance) از استراکت با استفاده از جفت‌های `key: value`، مشخص باشد که کدام مقدار به کدام فیلد مرتبط است. استراکت‌ها همچنین نیازی به رعایت ترتیب در هنگام نمونه‌سازی ندارند، بر خلاف تاپل‌ها که ترتیب در آن‌ها اهمیت دارد.

### بخش: تعریف، نمونه‌سازی و دسترسی

2.  **سوال:** چگونه یک استراکت (struct) در Rust تعریف می‌شود و چگونه می‌توان نمونه‌ای (instance) از آن ایجاد کرد؟ لطفا سینتکس (syntax) تعریف استراکت و نمونه‌سازی آن با استفاده از جفت‌های `key: value` را توضیح دهید.
    **پاسخ:** برای تعریف یک استراکت، از کلمه کلیدی `struct` استفاده کرده و سپس نام استراکت را می‌آوریم. نام استراکت باید معنادار باشد و توصیف‌کننده داده‌هایی باشد که گروه‌بندی می‌شوند. سپس در داخل براکت‌های کج‌معوج (`{}`)، فیلدهای (fields) استراکت را تعریف می‌کنیم که شامل نام فیلد و نوع داده آن است. مثال: `struct User { active: bool, username: String, email: String, sign_in_count: u64, }`.
    برای ایجاد یک نمونه (instance) از استراکت، نام استراکت را آورده و سپس در داخل براکت‌های کج‌معوج (`{}`)، جفت‌های `key: value` را برای هر فیلد مشخص می‌کنیم. `key` نام فیلد و `value` مقدار مشخصی است که می‌خواهیم در آن فیلد ذخیره کنیم. ترتیب فیلدها هنگام نمونه‌سازی اهمیت ندارد. مثال: `let user1 = User { active: true, username: String::from("someusername123"), email: String::from("someone@example.com"), sign_in_count: 1, };`.

3.  **سوال:** برای دسترسی به مقدار یک فیلد (field) خاص در یک نمونه استراکت، از چه نحوی (syntax) استفاده می‌شود؟ در صورتی که بخواهید مقدار یکی از فیلدهای یک نمونه استراکت را تغییر دهید، آن نمونه باید چه ویژگی داشته باشد (mutable بودن کل نمونه)؟
    **پاسخ:** برای دسترسی به مقدار یک فیلد خاص از یک نمونه استراکت، از نحوه نقطه (`.`) استفاده می‌شود. مثال: `user1.email`.
    برای تغییر مقدار یک فیلد در یک نمونه استراکت، **کل نمونه** باید قابل تغییر (mutable) باشد. Rust اجازه نمی‌دهد تنها فیلدهای خاصی را قابل تغییر اعلام کنید. برای قابل تغییر کردن یک نمونه، باید از کلمه کلیدی `mut` هنگام تعریف متغیر استفاده کرد. مثال: `let mut user1 = User { ... }; user1.email = String::from("anotheremail@example.com");`.

### بخش: سینتکس‌های کمکی در نمونه‌سازی

4.  **سوال:** "Field init shorthand" (نحوه کوتاه برای مقداردهی اولیه فیلد) چیست و چه زمانی می‌توان از آن در هنگام ساخت یک نمونه استراکت جدید استفاده کرد؟ مزیت اصلی این نحوه (syntax) چیست (جلوگیری از تکرار)؟ مثالی برای کاربرد آن ارائه دهید.
    **پاسخ:** "Field init shorthand" نحوی (syntax) است که در Rust به شما اجازه می‌دهد هنگام ساخت یک نمونه جدید از استراکت، اگر نام پارامتر (parameter) یا متغیر محلی که مقدار فیلد را فراهم می‌کند، دقیقاً همان نام فیلد در استراکت باشد، به جای نوشتن `field_name: field_name`، تنها نام فیلد را بنویسید.
    این نحوه زمانی استفاده می‌شود که نام متغیر محلی یا پارامتر تابع با نام فیلد استراکت مطابقت داشته باشد.
    مزیت اصلی آن **جلوگیری از تکرار** و کوتاه‌تر و خواناتر کردن کد است.
    مثال: در تابع `build_user(email: String, username: String)` که نمونه `User` را می‌سازد، اگر نام پارامترها (`email`, `username`) با نام فیلدها (`email`, `username`) یکسان باشد، به جای نوشتن:
    `User { active: true, username: username, email: email, sign_in_count: 1, }`
    می‌توان از "Field init shorthand" استفاده کرد و نوشت:
    `User { active: true, username, email, sign_in_count: 1, }`
    این دو کد دقیقاً یک رفتار دارند.

5.  **سوال:** کاربرد اصلی "Struct update syntax" (نحوه بروزرسانی استراکت) چیست و چگونه با استفاده از نحوه‌ی `..` عمل می‌کند (کپی کردن فیلدهای باقی‌مانده از نمونه دیگر)؟ هنگام استفاده از این نحوه (syntax) برای ایجاد نمونه‌ای جدید از روی نمونه‌ای دیگر، چه نکته مهمی در رابطه با مالکیت (ownership) داده‌ها وجود دارد (انتقال (move) داده‌ها مگر اینکه Copy trait پیاده‌سازی شده باشد)؟
    **پاسخ:** کاربرد اصلی "Struct update syntax" این است که به شما امکان می‌دهد یک نمونه (instance) جدید از استراکت را بر اساس مقادیر یک نمونه موجود ایجاد کنید، در حالی که فقط مقادیر تعدادی از فیلدها را تغییر می‌دهید و مابقی فیلدها مقادیر نمونه قبلی را داشته باشند.
    این نحوه با استفاده از `..other_instance` عمل می‌کند. این قسمت باید در **انتهای** لیست فیلدهای نمونه جدید قرار گیرد و مشخص می‌کند که برای فیلدهایی که به صراحت در نمونه جدید مقداردهی نشده‌اند، مقادیر متناظر آن‌ها از `other_instance` کپی یا منتقل شوند.
    نکته مهم در رابطه با مالکیت این است که "Struct update syntax" مانند یک انتساب (=) عمل می‌کند و **داده‌ها را منتقل (move) می‌کند**. این بدان معنی است که اگر فیلدهایی در نمونه قبلی وجود داشته باشند که نوع آن‌ها Trait `Copy` را پیاده‌سازی نکرده باشند (مانند `String`) و شما مقدار جدیدی برای آن فیلد در نمونه جدید تعیین نکنید و اجازه دهید با `..other_instance` از نمونه قبلی گرفته شود، مالکیت آن داده از نمونه قبلی به نمونه جدید منتقل می‌شود. پس از این انتقال، نمونه قبلی دیگر برای آن فیلد قابل استفاده نخواهد بود. با این حال، اگر نوع فیلد Trait `Copy` را پیاده‌سازی کرده باشد (مانند `u64` یا `bool`)، مقادیر آن فیلد کپی (copy) می‌شوند و نمونه قبلی همچنان معتبر باقی می‌ماند. همچنین اگر برای یک فیلد خاص (مانند `email` در مثال منابع) در نمونه جدید مقدار جدیدی تعیین کنید، مقدار آن فیلد در نمونه قبلی منتقل نمی‌شود و قابل استفاده باقی می‌ماند.

### بخش: انواع خاص استراکت‌ها

6.  **سوال:** Tuple structs چه نوع استراکت‌هایی هستند و تفاوت آن‌ها با استراکت‌های معمولی که فیلدهای نام‌دار دارند چیست (فیلدها نام ندارند، فقط نوع دارند)؟ در چه موقعیت‌هایی استفاده از tuple structs می‌تواند مفید باشد و چرا نمونه‌های مختلف tuple structs (حتی با انواع فیلدهای یکسان) به عنوان انواع (types) متفاوتی در نظر گرفته می‌شوند؟ مثالی برای تعریف و استفاده از آن‌ها بزنید.
    **پاسخ:** Tuple structs نوعی استراکت هستند که مانند تاپل‌ها چندین مقدار مرتبط را در خود نگه می‌دارند، اما برخلاف استراکت‌های معمولی، فیلدهای آن‌ها نام ندارند؛ بلکه تنها شامل **انواع داده‌های فیلدها** هستند.
    تفاوت اصلی آن‌ها با استراکت‌های معمولی در این است که استراکت‌های معمولی فیلدهای **نام‌دار** دارند (مثلاً `width: u32`) که شفافیت بیشتری در مورد معنی هر فیلد ارائه می‌دهند [5، 18]، در حالی که tuple structs فیلدهای **بی‌نام** دارند و فقط به نوع داده آن‌ها اشاره می‌شود.
    استفاده از tuple structs می‌تواند مفید باشد زمانی که می‌خواهید به یک تاپل نامی معنادار بدهید و آن را از سایر تاپل‌ها (حتی با ساختار مشابه) به یک نوع داده متفاوت تبدیل کنید. این کار زمانی منطقی است که نام‌گذاری صریح هر فیلد (مانند استراکت معمولی) تکراری یا غیرضروری به نظر برسد.
    نکته مهم این است که هر tuple struct که شما تعریف می‌کنید، یک **نوع (type) منحصر به فرد** محسوب می‌شود، حتی اگر فیلدهای آن ساختار و انواع داده یکسانی با یک tuple struct دیگر داشته باشند. به همین دلیل، تابعی که پارامتر نوع `Color(i32, i32, i32)` را می‌پذیرد، نمی‌تواند آرگومانی از نوع `Point(i32, i32, i32)` (با وجود اینکه هر دو سه مقدار `i32` دارند) بپذیرد) بپذیرد.
    مثال تعریف و استفاده:
    ```rust
    struct Color(i32, i32, i32); // تعریف tuple struct Color
    struct Point(i32, i32, i32); // تعریف tuple struct Point

    fn main() {
        let black = Color(0, 0, 0); // ایجاد نمونه از Color
        let origin = Point(0, 0, 0); // ایجاد نمونه از Point

        // دسترسی به فیلدها با ایندکس (مانند تاپل‌ها)
        // println!("Color: ({}, {}, {})", black.0, black.1, black.2); // نیاز به #[derive(Debug)] برای چاپ کامل نمونه نیست، می‌توان فیلدها را جداگانه چاپ کرد.

        // ساختارشکنی (Destructure) tuple struct
        let Point(x, y, z) = origin;
        println!("Point coordinates: x={}, y={}, z={}", x, y, z);
    }
    ```
   

7.  **سوال:** Unit-like structs چه ویژگی منحصر به فردی دارند (بدون فیلد)؟ چه کاربردی برای آن‌ها ذکر شده است (پیاده‌سازی trait زمانی که نیازی به ذخیره داده نیست) و چگونه می‌توان یک unit-like struct را تعریف و نمونه‌سازی کرد؟
    **پاسخ:** Unit-like structs استراکت‌هایی هستند که **هیچ فیلدی** ندارند. آن‌ها شبیه به نوع واحد (`()`) عمل می‌کنند.
    کاربرد اصلی ذکر شده برای آن‌ها این است که می‌توانید یک Trait (صفت) را روی آن‌ها پیاده‌سازی (implement) کنید، در حالی که خود استراکت نیازی به ذخیره هیچ داده‌ای ندارد. این موضوع در فصل 10 منابع به تفصیل بررسی می‌شود.
    نحوه تعریف یک unit-like struct این است که از کلمه کلیدی `struct`، نام استراکت، و سپس یک نقطه ویرگول (`;`) استفاده می‌کنید. بدون براکت‌های کج‌معوج یا پرانتز. مثال: `struct AlwaysEqual;`.
    نحوه نمونه‌سازی (instantiate) یک unit-like struct نیز با استفاده از نام آن، بدون هیچ براکت یا پرانتزی است. مثال: `let subject = AlwaysEqual;`.

### بخش: مالکیت و ارجاعات در استراکت‌ها

8.  **سوال:** چرا Rust بدون استفاده از مفهوم Lifetimes (که بعداً بررسی می‌شود) اجازه نمی‌دهد که استراکت‌ها به سادگی شامل ارجاعاتی (`&`) به داده‌هایی باشند که خود استراکت مالکیت آن‌ها را ندارد؟ لطفا خطای کامپایلر مربوط به "missing lifetime specifier" (مثل خطای E0106) را که در این حالت رخ می‌دهد، توضیح دهید و راه حل موقت ارائه شده چیست (استفاده از Owned types مانند String)؟
    **پاسخ:** دلیل اینکه Rust اجازه نمی‌دهد استراکت‌ها به سادگی ارجاعاتی (`&`) به داده‌های متعلق به بیرون از خود داشته باشند بدون استفاده از Lifetimes، این است که Rust تضمین می‌کند تمام ارجاعات معتبر هستند و به داده‌هایی اشاره می‌کنند که همچنان در حافظه وجود دارند. اگر استراکت حاوی ارجاعاتی باشد و داده‌ای که به آن ارجاع داده شده زودتر از استراکت از بین برود، ارجاع درون استراکت به داده نامعتبر اشاره خواهد کرد (dangling reference) که منجر به خطاهای زمان اجرا (runtime errors) می‌شود. Lifetimes مکانیزمی در Rust هستند که این مسئله را در زمان کامپایل بررسی کرده و تضمین می‌کنند که ارجاعات داخل استراکت حداقل به اندازه خود استراکت معتبر باقی بمانند.
    اگر تلاش کنید استراکتی تعریف کنید که شامل ارجاعاتی (مثل `&str`) باشد بدون مشخص کردن Lifetimes، کامپایلر Rust خطایی با پیام اصلی `missing lifetime specifier` (مثلاً خطای E0106) می‌دهد. این خطا به این معنی است که کامپایلر نمی‌تواند تضمین کند که ارجاعات در استراکت به اندازه کافی زنده می‌مانند.
    ## نکات مربوط به خطای `missing lifetime specifier` (E0106)
    هنگامی که استراکتی را تعریف می‌کنید که حاوی فیلدهایی از نوع ارجاع (borrow) است (مثلاً `&str` به جای `String`) بدون اینکه lifetime specifier مشخصی برای آن ارجاع تعیین کنید، کامپایلر Rust نمی‌تواند تضمین کند که داده‌ای که این ارجاع به آن اشاره دارد، حداقل به اندازه عمر (lifetime) خود استراکت معتبر باقی بماند. این منجر به خطای کامپایلر `error[E0106]: missing lifetime specifier` می‌شود.
    مثال کد منجر به خطا:
    ```rust
    struct User {
        active: bool,
        username: &str, // این ارجاع نیاز به lifetime specifier دارد
        email: &str,    // این ارجاع نیز نیاز به lifetime specifier دارد
        sign_in_count: u64,
    }

    fn main() {
        let user1 = User {
            active: true,
            username: "someusername123",
            email: "someone@example.com",
            sign_in_count: 1,
        };
    }
    ```
    خروجی کامپایلر شامل پیام خطا و راهنمایی به شکل زیر است:
    ```
    error[E0106]: missing lifetime specifier
    --> src/main.rs:3:15
     |
    3 | username: &str,
     | ^ expected named lifetime parameter
     | help: consider introducing a named lifetime parameter
     | 1 ~ struct User<'a> {
    ...
    error[E0106]: missing lifetime specifier
    --> src/main.rs:4:12
     |
    4 | email: &str,
     | ^ expected named lifetime parameter
     | help: consider introducing a named lifetime parameter
     | 1 ~ struct User<'a> {
    ...
    ```
    راهنمایی کامپایلر پیشنهاد می‌کند که یک lifetime parameter نام‌دار (مثلاً `'a`) به تعریف استراکت اضافه کنید.
    راه حل موقت ارائه شده در منابع (قبل از آموزش Lifetimes در فصل ۱۰) این است که به جای استفاده از انواع ارجاع (مانند `&str`)، از انواع داده‌ای که مالکیت داده را دارند (Owned types) مانند `String` استفاده کنید. با استفاده از `String`، هر نمونه استراکت مالک داده‌های رشته‌ای خود می‌شود و نیاز به تضمین lifetime توسط کامپایلر به این شکل از بین می‌رود.

### بخش: متدها و تابع‌های مرتبط

9.  **سوال:** متدها (Methods) در Rust چه هستند و چه تفاوتی با associated functions (تابع‌های مرتبط) دارند که پارامتر `self` را نمی‌گیرند؟ چگونه یک متد روی یک استراکت تعریف می‌شود (با استفاده از بلاک `impl`) و چگونه می‌توان آن را روی یک نمونه استراکت فراخوانی کرد (با استفاده از نحوه `.` یا method syntax)؟
    **پاسخ:** متدها (Methods) شبیه به توابع هستند، اما **درون زمینه (context) یک استراکت** (یا enum یا trait object) تعریف می‌شوند. ویژگی متمایز آن‌ها این است که **اولین پارامتر آن‌ها همیشه `self` است** که نشان‌دهنده نمونه‌ای (instance) از استراکت است که متد روی آن فراخوانی شده است.
    Associated functions (تابع‌های مرتبط) نیز درون بلاک `impl` برای یک استراکت تعریف می‌شوند و بنابراین با آن نوع مرتبط هستند. اما برخلاف متدها، **Associated functions پارامتر `self` را به عنوان اولین پارامتر خود دریافت نمی‌کنند**. این بدان معنی است که آن‌ها نیازی به نمونه خاصی از استراکت برای کار ندارند. مثال رایج Associated function، تابع `String::from` یا تابع‌های سازنده (constructor) مانند `Rectangle::square` هستند.
    برای تعریف یک متد روی یک استراکت، از بلاک `impl` استفاده می‌کنیم. ساختار کلی اینگونه است: `impl StructName { // تعریف متدها و associated functions در اینجا }`. متدها درون این بلاک با کلمه کلیدی `fn` تعریف می‌شوند و اولین پارامتر آن‌ها `self` (یا `&self` یا `&mut self`) است. مثال: `impl Rectangle { fn area(&self) -> u32 { self.width * self.height } }`.
    برای فراخوانی یک متد روی یک نمونه استراکت، از **Method syntax (نحوه متد)** استفاده می‌شود که شامل یک نقطه (`.`) بعد از نام نمونه استراکت و سپس نام متد به همراه پرانتزها و آرگومان‌های اضافی (اگر وجود داشته باشند) است. مثال: `rect1.area()`.

10. **سوال:** پارامتر `&self` در امضای یک متد چه چیزی را نشان می‌دهد (ارجاع immutable به نمونه‌ای که متد روی آن فراخوانی شده) و چرا استفاده از آن رایج است (مثلاً در متد `area`)؟ چه انواع دیگری از `self` (مانند `&mut self` برای ارجاع mutable یا `self` برای گرفتن مالکیت) وجود دارند و هر یک چه زمانی استفاده می‌شوند؟
    **پاسخ:** پارامتر `&self` در امضای یک متد (مثلاً `fn area(&self) -> u32`) نشان‌دهنده یک **ارجاع غیرقابل تغییر (immutable borrow)** به نمونه‌ای از استراکت است که متد روی آن فراخوانی شده است. `&self` در واقع نحوه کوتاهی برای `self: &Self` است، جایی که `Self` نام مستعار (alias) برای نوع استراکتی است که بلاک `impl` برای آن تعریف شده است.
    استفاده از `&self` رایج است زیرا در بسیاری از متدها، شما فقط نیاز دارید مقادیر فیلدهای نمونه استراکت را بخوانید و نمی‌خواهید آن‌ها را تغییر دهید یا مالکیت نمونه را بگیرید. این دقیقاً همان دلیلی است که در نسخه تابع `area` از `&Rectangle` استفاده شد: برای جلوگیری از گرفتن مالکیت توسط تابع و امکان استفاده مجدد از نمونه پس از فراخوانی متد. متد `area` فقط نیاز به خواندن `width` و `height` دارد، بنابراین `&self` کافی است.
    انواع دیگری از `self` که می‌توانند به عنوان اولین پارامتر متد استفاده شوند عبارتند از:
    *   `&mut self`: این نشان‌دهنده یک **ارجاع قابل تغییر (mutable borrow)** به نمونه استراکت است. از این نوع زمانی استفاده می‌شود که متد قصد تغییر (mutate) دادن یا نوشتن روی داده‌های نمونه‌ای را که روی آن فراخوانی شده، داشته باشد.
    *   `self`: این نشان‌دهنده **گرفتن مالکیت (taking ownership)** نمونه استراکت است. استفاده از این نوع کمتر رایج است و معمولاً زمانی به کار می‌رود که متد نمونه استراکت را به چیز دیگری تبدیل می‌کند (مانند متدی که `String` را به `Vec<u8>` تبدیل می‌کند) و شما می‌خواهید پس از فراخوانی متد، نمونه اصلی دیگر قابل استفاده نباشد.

11. **سوال:** ویژگی "automatic referencing and dereferencing" (ارجاع‌دهی و ارجاع‌گشایی خودکار) در Rust که در هنگام فراخوانی متدها فعال است، به چه معناست (Rust به طور خودکار `&`, `&mut`, یا `*` را اضافه می‌کند تا نوع نمونه با امضای متد تطابق پیدا کند)؟ چگونه این ویژگی استفاده از متدها را ساده می‌کند (نیاز به استفاده صریح از `&` یا `*` را کاهش می‌دهد) و چه ارتباطی با ارگونومیک (ergonomic) بودن سیستم مالکیت Rust دارد؟
    **پاسخ:** ویژگی "automatic referencing and dereferencing" در Rust به این معناست که هنگامی که شما یک متد را با استفاده از نحوه نقطه (`.`) روی یک شیء فراخوانی می‌کنید (مثلاً `object.something()`)، Rust به طور خودکار تشخیص می‌دهد که آیا متد به یک ارجاع غیرقابل تغییر (`&self`)، یک ارجاع قابل تغییر (`&mut self`) یا مالکیت کامل (`self`) نیاز دارد. سپس Rust به طور خودکار علامت `&` (برای ارجاع غیرقابل تغییر)، `&mut` (برای ارجاع قابل تغییر)، یا `*` (برای ارجاع‌گشایی و گرفتن مالکیت) را به شیء شما اضافه می‌کند تا با امضای متد مطابقت پیدا کند. نیازی نیست شما این عملیات ارجاع‌دهی یا ارجاع‌گشایی را به صراحت بنویسید.
    این ویژگی استفاده از متدها را بسیار ساده می‌کند زیرا نیاز به نوشتن صریح `&object.something()`, `&mut object.something()`, یا `(*object).something()` را از بین می‌برد و شما می‌توانید همیشه فقط `object.something()` را بنویسید.
    این رفتار خودکار در Rust به دلیل وجود "گیرنده مشخص" (clear receiver) در متدها (پارامتر `self`) ممکن است. Rust با توجه به نوع گیرنده و نام متد، می‌تواند به طور قطع تشخیص دهد که متد در حال خواندن (`&self`)، تغییر دادن (`&mut self`)، یا مصرف کردن (`self`) نمونه است. این واقعیت که Rust ارجاع‌دهی را برای گیرنده‌های متد ضمنی می‌کند، بخش بزرگی از **ارگونومیک (ergonomic)** بودن (یعنی راحت و طبیعی بودن استفاده) سیستم مالکیت Rust در عمل است.

### بخش: چاپ و دیباگینگ

12. **سوال:** چرا تلاش برای چاپ مستقیم یک نمونه استراکت (مثل `Rectangle`) با استفاده از ماکروی `println!` و placeholder ساده `{}` با خطا مواجه می‌شود؟ این خطا به کدام trait (صفت) مربوط است (std::fmt::Display)؟ برای چاپ اطلاعات یک استراکت به منظور دیباگینگ (debugging)، باید از کدام trait (Debug) و کدام نحوه (syntax) در `println!` استفاده کرد (`{:?}` یا `{:#?}`)؟
    **پاسخ:** تلاش برای چاپ مستقیم یک نمونه استراکت با استفاده از `println!` و placeholder `{}` با خطا مواجه می‌شود زیرا Rust نمی‌داند چگونه یک استراکت را به صورت متنی برای نمایش به کاربر نهایی (Display) قالب‌بندی کند. برخلاف انواع اولیه (primitive types) که فقط یک راه مشخص برای نمایش دارند (مانند عدد 1)، برای استراکت‌ها روش‌های مختلفی برای نمایش وجود دارد (مثلاً آیا فیلدها با کاما جدا شوند؟ براکت‌ها نمایش داده شوند؟) و Rust حدس نمی‌زند که شما کدام قالب‌بندی را می‌خواهید.
    این خطا مربوط به پیاده‌سازی نشدن Trait (صفت) `std::fmt::Display` برای آن استراکت است. Trait `Display` برای خروجی در نظر گرفته شده که مستقیماً برای کاربر نهایی است.
    برای چاپ اطلاعات یک استراکت به منظور دیباگینگ (debugging) و استفاده توسعه‌دهندگان، باید از Trait `Debug` استفاده کرد. برای استفاده از این Trait، ابتدا باید با افزودن صفت `#[derive(Debug)]` بالای تعریف استراکت، به کامپایلر اجازه دهید به طور خودکار کد لازم برای پیاده‌سازی این Trait را تولید کند. سپس در ماکروی `println!` باید از نحوه (syntax) `{:?}` یا `{:#?}` به جای `{}` استفاده کنید.
    *   `{:?}`: برای خروجی استاندارد و مختصر Debug استفاده می‌شود.
    *   `{:#?}`: برای خروجی Debug خواناتر و با فرمت‌بندی بهتر (pretty-print)، به خصوص برای استراکت‌های بزرگتر، استفاده می‌شود.

13. **سوال:** لطفاً کد زیر را که منجر به خطا می‌شود، همراه با خطای کامپایلر توضیح دهید و نکات کلیدی مربوط به خطای اجرا و نحوه رفع آن را بیان کنید.
    ```rust
    struct Rectangle {
        width: u32,
        height: u32,
    }

    fn main() {
        let rect1 = Rectangle {
            width: 30,
            height: 50,
        };
        println!("rect1 is {}", rect1); // تلاش برای چاپ مستقیم استراکت
    }
    ```
    **پاسخ:**
    کد بالا تلاش می‌کند تا یک نمونه از استراکت `Rectangle` را مستقیماً با استفاده از ماکروی `println!` و placeholder `{}` چاپ کند. این کار منجر به خطای کامپایل می‌شود.
    ## نکات مربوط به خطای اجرای کد (چاپ استراکت بدون Debug)
    هنگامی که این کد را کامپایل می‌کنید، خطایی با پیام اصلی زیر دریافت خواهید کرد:
    ```
    error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
    ```
    این پیام خطا نشان می‌دهد که استراکت `Rectangle` Trait `std::fmt::Display` را پیاده‌سازی (implement) نکرده است. همانطور که قبلاً گفته شد، Rust نمی‌داند چگونه یک استراکت را برای نمایش به کاربر نهایی قالب‌بندی کند.
    پیام خطا همچنین یک راهنمایی مهم ارائه می‌دهد:
    ```
    = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    ```
    این راهنمایی پیشنهاد می‌کند که می‌توانید از `{:?}` یا `{:#?}` که مربوط به Trait `Debug` هستند، استفاده کنید.
    اگر placeholder را به `{:?}` تغییر دهید (`println!("rect1 is {:?}", rect1);`)، خطای دیگری دریافت خواهید کرد:
    ```
    error[E0277]: `Rectangle` doesn't implement `Debug`
    ```
    این خطا نشان می‌دهد که Trait `Debug` نیز برای استراکت `Rectangle` به طور پیش‌فرض پیاده‌سازی نشده است.
    راهنمایی کامپایلر برای این خطا این بار دقیق‌تر است:
    ```
    = help: the trait `Debug` is not implemented for `Rectangle`
    = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
    ```
    این راهنمایی کلید حل مشکل است: برای اینکه بتوانید از قالب‌بندی Debug استفاده کنید، باید به Rust اجازه دهد که Trait `Debug` را برای استراکت شما پیاده‌سازی کند. ساده‌ترین راه برای انجام این کار، افزودن **صفت (attribute)** `#[derive(Debug)]` بالای تعریف استراکت است.
    **نحوه رفع خطا:**
    کد اصلاح شده برای چاپ موفقیت‌آمیز نمونه `Rectangle` با استفاده از قالب‌بندی Debug:
    ```rust
    #[derive(Debug)] // افزودن این صفت
    struct Rectangle {
        width: u32,
        height: u32,
    }

    fn main() {
        let rect1 = Rectangle {
            width: 30,
            height: 50,
        };
        println!("rect1 is {:?}", rect1); // استفاده از {:?}
        // یا برای خروجی خواناتر:
        // println!("rect1 is {:#?}", rect1); // استفاده از {:#?}
    }
    ```
    با افزودن `#[derive(Debug)]` و استفاده از `{:?}` (یا `{:#?}`)، کامپایلر Trait `Debug` را پیاده‌سازی می‌کند و کد بدون خطا اجرا می‌شود. خروجی شامل نام استراکت و مقادیر فیلدهای آن خواهد بود.

14. **سوال:** ماکروی `dbg!` در Rust برای چه منظوری استفاده می‌شود (دیباگینگ) و چه اطلاعات اضافی (مانند فایل و شماره خط فراخوانی ماکرو و عبارت در حال دیباگ) نسبت به `println!` ارائه می‌دهد؟ تفاوت اصلی آن با `println!` در مورد مالکیت (ownership) چیست (`dbg!` مالکیت عبارت را می‌گیرد و برمی‌گرداند، در حالی که `println!` ارجاع می‌گیرد)؟ مثالی از نحوه استفاده از `dbg!` برای بررسی مقدار یک عبارت و یک نمونه استراکت بزنید.
    **پاسخ:** ماکروی `dbg!` عمدتاً برای **دیباگینگ (debugging)** استفاده می‌شود. این ماکرو بر خلاف `println!` که فقط مقدار قالب‌بندی شده را چاپ می‌کند، اطلاعات اضافی برای کمک به دیباگینگ ارائه می‌دهد.
    اطلاعات اضافی که `dbg!` چاپ می‌کند شامل:
    *   مسیر فایل و شماره خطی که ماکرو در آن فراخوانی شده است.
    *   عبارتی که به ماکرو پاس داده‌اید.
    *   و در نهایت، نتیجه ارزیابی آن عبارت با استفاده از قالب‌بندی **Debug**.
    `dbg!` خروجی خود را به Standard Error (stderr) می‌فرستد، در حالی که `println!` به Standard Output (stdout) می‌فرستد.
    تفاوت اصلی `dbg!` با `println!` در مورد مالکیت (ownership) این است که **`dbg!` مالکیت عبارتی که به آن داده می‌شود را می‌گیرد، مقدار آن را چاپ می‌کند و سپس مالکیت را برمی‌گرداند**. این بدان معنی است که می‌توانید `dbg!` را اطراف یک عبارت قرار دهید و نتیجه آن عبارت را در همان خط به یک متغیر اختصاص دهید یا از آن استفاده کنید. در مقابل، `println!` به طور معمول یک **ارجاع** به مقداری که می‌خواهید چاپ کنید می‌گیرد.
    مثال استفاده از `dbg!`:
    ```rust
    #[derive(Debug)]
    struct Rectangle {
        width: u32,
        height: u32,
    }

    fn main() {
        let scale = 2;
        // dbg! مالکیت عبارت 30 * scale را می‌گیرد، چاپ می‌کند، و نتیجه (60) را برمی‌گرداند.
        // این نتیجه سپس به width اختصاص داده می‌شود.
        let rect1 = Rectangle {
            width: dbg!(30 * scale),
            height: 50,
        };

        // dbg! یک ارجاع به rect1 می‌گیرد (&rect1) چون نمی‌خواهیم مالکیت کل struct منتقل شود.
        dbg!(&rect1);
    }
    ```
    خروجی این کد شبیه به این خواهد بود:
    ```
    [src/main.rs:10:16] 30 * scale = 60 // اطلاعات فایل، خط، عبارت، و نتیجه
    [src/main.rs:14:5] &rect1 = Rectangle { width: 60, height: 50, } // اطلاعات فایل، خط، عبارت، و نتیجه (با قالب Debug)
    ```
   

### بخش: سازماندهی کد با `impl`

15. **سوال:** آیا یک استراکت می‌تواند بیش از یک بلاک `impl` داشته باشد؟ در مثال ارائه‌شده (جدا کردن متدهای `area` و `can_hold`)، تفاوت عملی بین استفاده از یک یا چند بلاک `impl` چیست (هیچ تفاوتی در عملکرد وجود ندارد) و چه زمانی ممکن است داشتن چند بلاک `impl` واقعاً مفید باشد (مثلاً در کار با Generic types و Traits)?
    **پاسخ:** بله، یک استراکت در Rust **اجازه دارد چندین بلاک `impl` داشته باشد**.
    در مثال ساده‌ای مانند جدا کردن متدهای `area` و `can_hold` در بلاک‌های `impl` جداگانه در مقایسه با قرار دادن هر دو در یک بلاک `impl`، **هیچ تفاوت عملی در نحوه استفاده یا عملکرد کد وجود ندارد**. این دو روش از نظر کارایی معادل هستند.
    اگرچه در موارد ساده تفاوتی ایجاد نمی‌کند، اما داشتن چندین بلاک `impl` می‌تواند در موقعیت‌های پیشرفته‌تر مفید باشد. به عنوان مثال، زمانی که با **Generic types (انواع عمومی)** و **Traits (صفات)** کار می‌کنید، ممکن است بخواهید پیاده‌سازی‌های (implementations) مختلفی از متدها را برای استراکت خود داشته باشید که تحت شرایط خاصی (بر اساس نوع عمومی یا Trait پیاده‌سازی شده) فعال می‌شوند. منابع ذکر می‌کنند که در فصل ۱۰ به مواردی اشاره می‌شود که استفاده از چندین بلاک `impl` واقعاً کاربردی است.