//  می‌خواهیم ببینیم که چطوری می‌توانیم بدون انتقال مالکیّت یک مقدار
//  امکان استفاده از آن‌را به یک تابع بدهیم.

// وقتی که علامت & پشت یک نوع یا متغیّر قرارمی‌گیرد، یعنی داریم از یک 
// reference
//  صحبت می‌کنیم.
// در حقیقت 
// reference
// به یک مقدار اشاره می‌کند.

// fn main() {
//     let a = String::from("hello");
//     i_am_owner(&a);                                            //&a
//     println!("a in main function: {}", a);
// }
// fn i_am_owner(input: &String) {                              //&String
//     println!("The input value is: {}", input);
// }


// Dereferencing
// متضاد رفرنس دادن، 
// dereferencing
//  نامیده می‌شود. یعنی به مقداری که 
// reference
//  دارد به آن اشاره می‌کند دسترسی پیدا می‌کنیم.
// برای دسترسی به مقدار یک رفرنس، باید قبل از آن علامت * را قرار بدهیم. 

// fn main() {
//     let a = String::from("hello");
//     i_am_owner(&a);
//     println!("a in main function: {}", a);
// }
// fn i_am_owner(input: &String) {
//     println!("The input value is: {}", *input);                  //*input
// }

// از رفرنس‌ها برای عدم انتقال مالکیّت استفاده می شود
// به این کار در 
// Rust
//  اصطلاحاً 
// borrowing
//  یا همان قرض‌گرفتن می‌گویند.


// fn main() {
//     let mut a = String::from("hello");           //mut a
//     modifier(&mut a);                            //&mut a
//     println!("a in main function: {}", a);
// }
// fn modifier(reference: &mut String) {            //&mut String
//     reference.push_str(" a new string to push to the old one");
// }

///----------------------------------------
//              نکته
//----------------------------------------

// ما نمی‌توانیم از یک رفرنس 
// immutable
//  به عنوان یک رفرنس 
// mutable
//  استفاده کنیم.
// یعنی نمی‌توان مقداری که به عنوان مقدار 
// immutable
//  قرض‌گرفته شده است را به عنوان یک مقدار 
//  mutable
//   استفاده کرد و آن‌را تغییر داد.
//----------------------------------------
//              نکته
//----------------------------------------
// ۱)متغیّر اصلی باید 
// mutable
//  باشد.
// ۲)خود رفرنس هم باید 
// mutable
//  باشد. برای این کار باید بعد از علامت & کلمه‌ی 
//  mut
//   را قرار دهیم.


//----------------------------------------
//              رفرنس‌دهی چند گانه
//----------------------------------------
// تابع درست

fn main() {
    let a = String::from("hello");
    let reference1 = &a;
    let reference2 = &a;
    ali(reference1);
    hossein(reference2);
    println!("a in main function: {}", a);

}

fn ali(original_text: &String) {
    println!("Ali says: {}", original_text);
}

fn hossein(text: &String) {
    println!("{} hossein", text);
}

// تابع زیر غلط چرا:


fn main() {
    let mut a = String::from("hello");
    let reference1 = &a;
    let reference2 = &a;
    let reference3 = &mut a;    

    ali(reference1);
    mohammad(reference3);
    hossein(reference2);
    println!("a in main function: {}", a);
}
fn ali(original_text: &String) {
    println!("Ali says: {}", original_text);
}
fn hossein(text: &String) {
    println!("{} hossein", text);
}
fn mohammad(original_input: &mut String) {
    original_input.push_str("!");
}
// نمی‌تواند یک رفرنس 
// mutable
// به متغیّر 
// a
// اضافه کند، چون پیش از آن، و البته به صورت همزمان در یک 
// scope
// ، رفرنس‌های 
// immutable
// به این متغیّر ساخته شده است.

//----------------------------------------
//             Data Race
//----------------------------------------
// اگر برخی رفرنس ها از نوع 
// mut
// ,و برخی از نوع
// immutable
// باشند
// اگر بیش از یک اشاره‌گر نویسنده داشته باشیم قضیه بدتر می‌شود. در این حالت هر رفرنس 
// mutable
//  هم می‌تواند کار بخش‌هایی که صرفاً دارند داده‌را می‌خوانند خراب کند،
//   و هم می‌تواند با قراردادن داده‌های خود مابین داده‌های رفرنس 
// mutable
//  دیگر، داده‌های آن‌را هم خراب کند.


//----------------------------------------
//           محدودیت‌های ساخت رفرنس
//----------------------------------------
// ۱) دو یا چند اشاره‌گررفرنس به صورت هم‌زمان به یک داده دسترسی داشته باشند.
// ۲) حدّاقل یکی از این اشاره‌گرها برای نوشتن روی داده استفاده شوند 
// (رفرنس mutable).

//----------------------------------------
//         هم‌زمان بودن اشاره‌گرها
//----------------------------------------
// زمانی دوتا رفرنس به صورت هم‌زمان داریم که آن‌ها درون یک 
// scope 
// واحد تعریف شده باشند

//  به خطا میخوریم

// let mut a = String::from("hello");
// let reference1 = &a;
// let reference2 = &a;
// let reference3 = &mut a;    

//  به خطا نمیخوریم

// let mut a = String::from("hello");
// ali(&a);
// mohammad(&mut a);
// hossein(&a);
// چرا

// امّا این بار این سه رفرنس هم‌زمان ایجاد نشده اند. چون هرکدام مربوط به یک 
// scope
// مختلف هستند.
// یعنی رفرنس اوّل متعلّق به 
// scope
// تابع 
// ali
// است، دومی متعلّق به 
// scope
// تابع 
// mohammad
// و سومی هم متعلّق به تابع 
// hossein.

// این برنامه‌ هم به صورت 
// sequential
// اجرا می‌شود نه 
// parallel

//----------------------------------------
//          Dangling reference         
//----------------------------------------
// Dangling reference 
// به رفرنسی گفته می‌شود که به جایی از حافظه اشاره می‌کند
// که دیگر داده‌ای که انتظارش می‌رود در آنجا نیست.
// این اتّفاق زمانی می‌افتد که با آزاد شدن حافظه،
// آن مکان الان به جای دیگری اختصاص پیدا کرده است یا اینکه دیگر داده‌های قبلی به خاطر 
// free
// شدن به صورت 
// valid
// در آن‌جا قرار ندارند.


// مثال
// کد زیر اشتباه است

// fn main() {
//     let b = dangle_generator();
//     println!("a in main function: {}", b);
// }
// fn dangle_generator() -> &String {
//     let a = String::from("hello");
//     &a
// }

// متغیّر 
// a
// یک متغیّر محلّی درون تابع 
// dangle_generator
// است. بنابراین با به انتها رسیدن 
// scope
// این تابع، این مقدار هم 
// drop
// می‌شود و دیگر در دسترس نیست.
// حالا ما داریم تلاش می‌کنیم یک رفرنس به مقداری که از بین خواهد رفت‌را برگردانیم.
// یعنی می‌خواهیم به چیزی که اصلاً دیگر وجود ندارد رفرنس بدهیم.



