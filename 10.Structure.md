<html dir="rtl">
<!-- </html> -->


برنامه‌نویسی با Rust به شما امکان می‌دهد تا انواع داده‌ی سفارشی خود را ایجاد کنید که برای حوزه‌ی خاص برنامه‌ی شما معنادار باشند. Structها یکی از راه‌های اصلی برای انجام این کار هستند. آن‌ها به شما اجازه می‌دهند تا چندین مقدار مرتبط را که یک گروه معنادار را تشکیل می‌دهند، بسته‌بندی کرده و نام‌گذاری کنید. Structها شبیه به Tupleها هستند زیرا هر دو چندین مقدار مرتبط را نگهداری می‌کنند و قطعات آن‌ها می‌توانند از انواع مختلفی باشند. با این حال، برخلاف Tupleها، در Structها شما به هر قطعه داده یک نام اختصاص می‌دهید که به وضوح معنی مقادیر را مشخص می‌کند. این نام‌گذاری باعث می‌شود Structها انعطاف‌پذیرتر از Tupleها باشند، زیرا برای دسترسی به مقادیر یک نمونه (Instance)، لازم نیست به ترتیب داده‌ها تکیه کنید.

**تعریف و نمونه‌سازی Structها**
برای تعریف یک Struct، از کلمه‌ی کلیدی `struct` و سپس نام کلی Struct استفاده می‌کنیم. نام Struct باید اهمیت قطعات داده‌ای که با هم گروه‌بندی می‌شوند را توصیف کند. سپس، داخل براکت‌های فرفری (`{}`)، نام‌ها و انواع قطعات داده را که آن‌ها را **فیلد** می‌نامیم، تعریف می‌کنیم. به عنوان مثال، Structی برای ذخیره‌ی اطلاعات حساب کاربری به این صورت تعریف می‌شود:
```rust
struct User {
 active: bool,
 username: String,
 email: String,
 sign_in_count: u64,
}
```
این تعریف مانند یک الگو (Template) کلی برای نوع داده است.

برای استفاده از یک Struct پس از تعریف آن، یک **نمونه (Instance)** از آن Struct ایجاد می‌کنیم. این کار با مشخص کردن مقادیر واقعی برای هر فیلد انجام می‌شود. شما یک نمونه را با ذکر نام Struct و سپس افزودن براکت‌های فرفری حاوی جفت‌های **کلید: مقدار** ایجاد می‌کنید، که در آن کلیدها نام فیلدها و مقدارها داده‌هایی هستند که می‌خواهید در آن فیلدها ذخیره کنید. نیازی نیست فیلدها را به همان ترتیبی که در تعریف Struct اعلام کرده‌اید، مشخص کنید. مثلاً، یک کاربر خاص می‌تواند به این صورت تعریف شود:
```rust
let user1 = User {
 active: true,
 username: String::from("someusername123"),
 email: String::from("someone@example.com"),
 sign_in_count: 1,
};
```
این نمونه، `user1`، مقادیر خاصی را در الگوی `User` پر می‌کند تا یک مقدار از این نوع ایجاد شود.

برای دسترسی به یک مقدار خاص از یک Struct، از **سینتکس نقطه** استفاده می‌کنیم. برای مثال، برای دسترسی به آدرس ایمیل این کاربر، از `user1.email` استفاده می‌کنیم. اگر نمونه قابل تغییر (Mutable) باشد، می‌توانیم با استفاده از سینتکس نقطه و انتساب به یک فیلد خاص، مقدار آن را تغییر دهیم. کل نمونه باید قابل تغییر باشد؛ Rust به ما اجازه نمی‌دهد فقط فیلدهای خاصی را قابل تغییر علامت‌گذاری کنیم.

**خلاصه‌نویسی در ایجاد نمونه Struct**
اغلب در توابعی که نمونه Struct برمی‌گردانند، نام پارامترهای تابع با نام فیلدهای Struct یکسان است. در این موارد، برای جلوگیری از تکرار نام فیلدها و متغیرها، می‌توان از **سینتکس خلاصه‌ی مقداردهی فیلد (Field Init Shorthand)** استفاده کرد.
تابعی که یک نمونه `User` را با ایمیل و نام کاربری داده شده برمی‌گرداند:
```rust
fn build_user(email: String, username: String) -> User {
 User {
  active: true,
  username: username, // نام فیلد و نام پارامتر یکسان است
  email: email,       // نام فیلد و نام پارامتر یکسان است
  sign_in_count: 1,
 }
}
```
با استفاده از Field Init Shorthand، می‌توانیم آن را به این صورت ساده‌تر بنویسیم:
```rust
fn build_user(email: String, username: String) -> User {
 User {
  active: true,
  username, // کافی است فقط نام را بنویسیم
  email,    // کافی است فقط نام را بنویسیم
  sign_in_count: 1,
 }
}
```
این به این معنی است که ما می‌خواهیم فیلد `email` Struct با مقدار پارامتر `email` تابع مقداردهی شود، چون نام آن‌ها یکسان است.

ایجاد یک نمونه‌ی جدید از Struct که بیشتر مقادیر آن از یک نمونه‌ی دیگر گرفته شده باشد، اما بعضی تغییر کرده باشند، نیز رایج است. می‌توان این کار را با استفاده از **سینتکس به‌روزرسانی Struct (Struct Update Syntax)** انجام داد.
بدون استفاده از این سینتکس، برای ایجاد `user2` با بیشتر مقادیر از `user1`:
```rust
let user1 = User {
 email: String::from("someone@example.com"),
 username: String::from("someusername123"),
 active: true,
 sign_in_count: 1,
};
let user2 = User {
 active: user1.active,
 username: user1.username,
 email: String::from("another@example.com"), // تغییر این فیلد
 sign_in_count: user1.sign_in_count,
};
```
با استفاده از سینتکس به‌روزرسانی Struct، می‌توان همین کار را با کد کمتری انجام داد:
```rust
let user1 = User {
 email: String::from("someone@example.com"),
 username: String::from("someusername123"),
 active: true,
 sign_in_count: 1,
};
let user2 = User {
 email: String::from("another@example.com"), // مشخص کردن فیلد جدید
 ..user1 // استفاده از مقادیر باقی فیلدها از user1
};
```
سینتکس `..` مشخص می‌کند که فیلدهای باقی‌مانده که به صراحت تنظیم نشده‌اند، باید همان مقدار فیلدهای متناظر را در نمونه‌ی داده شده داشته باشند. توجه داشته باشید که سینتکس به‌روزرسانی Struct از `=` مانند انتساب استفاده می‌کند زیرا داده‌ها را **انتقال (Move)** می‌دهد. در مثال بالا، `String` در فیلد `username` از `user1` به `user2` منتقل شد، بنابراین پس از ایجاد `user2` نمی‌توانیم از `user1` استفاده کنیم (اگرچه هنوز می‌توانیم به `user1.email` دسترسی داشته باشیم زیرا مقدار آن منتقل نشده است). اگر فیلدهایی از `user1` که دارای نوعی هستند که ویژگی `Copy` را پیاده‌سازی می‌کنند استفاده شوند، `user1` همچنان معتبر باقی می‌ماند.

**انواع Structها بدون فیلدهای نام‌گذاری شده یا بدون هیچ فیلدی**
Rust از Structهایی شبیه به Tupleها نیز پشتیبانی می‌کند که **Tuple Struct** نامیده می‌شوند. این Structها نامی برای کلیت Struct فراهم می‌کنند اما فیلدهای آن‌ها نامی ندارند و فقط نوع فیلدها را مشخص می‌کنند. Tuple Structها زمانی مفید هستند که بخواهید به کل Tuple نامی بدهید و آن را نوعی متفاوت از Tupleهای دیگر بسازید، و وقتی نام‌گذاری هر فیلد مانند Structهای معمولی طولانی یا اضافی باشد. برای تعریف یک Tuple Struct، با کلمه‌ی کلیدی `struct` و نام Struct شروع کرده و سپس انواع داده‌ها را داخل پرانتز می‌آورید.
مثال‌هایی از تعریف و استفاده از دو Tuple Struct به نام `Color` و `Point`:
```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
 let black = Color(0, 0, 0);
 let origin = Point(0, 0, 0);
}
```
توجه کنید که مقادیر `black` و `origin` **انواع متفاوتی** دارند، زیرا نمونه‌هایی از Tuple Structهای مختلف هستند. هر Structی که تعریف می‌کنید، نوع خودش است، حتی اگر فیلدهای درون Structها انواع یکسانی داشته باشند.

همچنین می‌توانید Structهایی تعریف کنید که **هیچ فیلدی** ندارند! این‌ها **Structهای واحد مانند (Unit-Like Structs)** نامیده می‌شوند، زیرا شبیه به `()`، نوع واحد (Unit Type) هستند. Structهای واحد مانند می‌توانند زمانی مفید باشند که نیاز به پیاده‌سازی یک Trait روی نوعی داشته باشید اما هیچ داده‌ای برای ذخیره در خود نوع نداشته باشید.
مثالی از تعریف و نمونه‌سازی یک Struct واحد به نام `AlwaysEqual`:
```rust
struct AlwaysEqual;

fn main() {
 let subject = AlwaysEqual;
}
```
برای تعریف `AlwaysEqual`، از کلمه‌ی کلیدی `struct`، نام مورد نظر و سپس یک نقطه ویرگول استفاده می‌کنیم. نیازی به براکت فرفری یا پرانتز نیست. سپس می‌توانیم یک نمونه از `AlwaysEqual` در متغیر `subject` به روشی مشابه ایجاد کنیم: با استفاده از نامی که تعریف کردیم، بدون براکت فرفری یا پرانتز.

**مالکیت داده‌های Struct**
در تعریف Struct `User` در مثال‌های قبل، از نوع `String` که مالکیت دارد استفاده شد، نه از نوع String Slice `&str`. این یک انتخاب آگاهانه است، زیرا می‌خواهیم هر نمونه از این Struct مالک تمام داده‌های خود باشد و آن داده‌ها تا زمانی که کل Struct معتبر است، معتبر باشند. امکان‌پذیر است که Structها به داده‌هایی که متعلق به چیز دیگری هستند (یعنی ارجاعات) ارجاع دهند، اما برای این کار نیاز به استفاده از **Lifetimes** است. Lifetimes تضمین می‌کنند که داده‌های مرجع شده توسط یک Struct تا زمانی که Struct معتبر است، معتبر باقی بمانند. اگر سعی کنید یک ارجاع را در Structی بدون تعیین Lifetimes ذخیره کنید، کد کامپایل نخواهد شد و با خطا مواجه می‌شوید.
مثال کدی که خطا ایجاد می‌کند:
```rust
struct User {
 active: bool,
 username: &str, // خطا اینجا رخ می‌دهد
 email: &str,    // خطا اینجا رخ می‌دهد
 sign_in_count: u64,
}

fn main() {
 let user1 = User {
  active: true,
  username: "someusername123",
  email: "someone@example.com",
  sign_in_count: 1,
 };
}
```
کامپایلر با این پیام‌های کلیدی خطا مواجه خواهد شد:
`error[E0106]: missing lifetime specifier`
این خطا نشان می‌دهد که Struct نیاز به مشخص‌کننده‌ی Lifetimes برای ارجاعات (`&str`) دارد. کامپایلر همچنین راهنمایی مفیدی ارائه می‌دهد:
`help: consider introducing a named lifetime parameter`
برای مثال، پیشنهاد می‌کند Struct را به صورت `struct User<'a> { ... username: &'a str, email: &'a str, ... }` تعریف کنید. Rust بدون Lifetimes نمی‌تواند تضمین کند که ارجاعات (`&str`) درون Struct معتبر باقی بمانند، و بنابراین این کد را رد می‌کند. در فصل ۱۰ این موضوع به تفصیل توضیح داده می‌شود. برای حل این خطاها بدون استفاده از Lifetimes، می‌توان از انواع مالکیتی مانند `String` به جای ارجاعاتی مانند `&str` استفاده کرد، همانطور که در Struct `User` اصلی انجام شد.

**متدها و توابع مرتبط با Structها**
**متدها** شبیه به توابع هستند، اما درون متن یک Struct تعریف می‌شوند و اولین پارامتر آن‌ها همیشه `self` است که نمونه‌ی Structی را که متد روی آن فراخوانی می‌شود، نشان می‌دهد. برای تعریف متدها، از بلوک `impl` (پیاده‌سازی) برای Struct مورد نظر استفاده می‌کنیم. هر چیزی که داخل بلوک `impl` قرار می‌گیرد، با نوع Struct مرتبط خواهد بود.

بیایید تابع `area` را که مساحت یک مستطیل را حساب می‌کرد و یک نمونه `Rectangle` به عنوان پارامتر می‌گرفت، به یک متد `area` تعریف شده روی Struct `Rectangle` تبدیل کنیم:
```rust
#[derive(Debug)] // اضافه شده برای قابلیت چاپ در مثال بعدی
struct Rectangle {
 width: u32,
 height: u32,
}

impl Rectangle { // بلوک پیاده‌سازی برای Rectangle
 fn area(&self) -> u32 { // تعریف متد area
  self.width * self.height
 }
}

fn main() {
 let rect1 = Rectangle { width: 30, height: 50, };
 println!(
  "The area of the rectangle is {} square pixels.",
  rect1.area() // فراخوانی متد با سینتکس نقطه
 );
}
```
در امضای متد `area`، از `&self` به جای `rectangle: &Rectangle` استفاده کرده‌ایم. `&self` در واقع کوتاه‌نوشت `self: &Self` است. در یک بلوک `impl`، نوع `Self` نام مستعار برای نوعی است که بلوک `impl` برای آن است (در اینجا `Rectangle`). متدها باید پارامتری به نام `self` از نوع `Self` به عنوان اولین پارامتر داشته باشند. Rust اجازه می‌دهد این را با تنها نام `self` در جایگاه پارامتر اول خلاصه کنید. `&` در `&self` نشان می‌دهد که این متد نمونه‌ی `Self` را به صورت **ارجاع غیرقابل تغییر (Immutable Borrow)** قرض می‌گیرد. این کار مشابه استفاده از `&Rectangle` در نسخه‌ی تابع است. ما اینجا `&self` را انتخاب کردیم زیرا نمی‌خواهیم مالکیت نمونه را بگیریم و فقط می‌خواهیم داده‌های Struct را بخوانیم، نه آن‌ها را تغییر دهیم.

متدها می‌توانند نمونه‌ی `self` را به صورت ارجاع قابل تغییر (`&mut self`) قرض بگیرند یا مالکیت آن را به صورت کامل (`self`) بگیرند. استفاده از `&mut self` زمانی است که می‌خواهید نمونه‌ای که متد روی آن فراخوانی شده است را به عنوان بخشی از کار متد تغییر دهید. گرفتن مالکیت نمونه (`self`) نادر است و معمولاً زمانی استفاده می‌شود که متد `self` را به چیز دیگری تبدیل می‌کند و می‌خواهید از استفاده‌ی فراخواننده از نمونه‌ی اصلی پس از تبدیل جلوگیری کنید.

یکی از دلایل اصلی استفاده از متدها به جای توابع مستقل، علاوه بر ارائه‌ی سینتکس متد (`.`) و عدم تکرار نوع `self` در امضای هر متد، برای **سازمان‌دهی** کد است. با استفاده از بلوک‌های `impl`، تمام کارهایی که می‌توان با یک نمونه از یک نوع انجام داد، در یک مکان جمع‌آوری می‌شود.

Rust دارای ویژگی به نام **ارجاع‌دهی و درارجاع‌دهی خودکار (Automatic Referencing and Dereferencing)** است. این ویژگی در زمان فراخوانی متدها بسیار کاربردی است. وقتی متدی را با `object.something()` فراخوانی می‌کنید، Rust به طور خودکار `&`، `&mut` یا `*` را اضافه می‌کند تا `object` با امضای متد مطابقت داشته باشد. این بدان معناست که نوشتن `rect1.area()` معادل نوشتن `(&rect1).area()` است، اما اولی خواناتر است.

متدها می‌توانند پارامترهای بیشتری داشته باشند که بعد از پارامتر `self` به امضای آن‌ها اضافه می‌شوند. این پارامترها مانند پارامترها در توابع معمولی عمل می‌کنند.
مثالی از یک متد دیگر به نام `can_hold` که روی `Rectangle` تعریف می‌شود و بررسی می‌کند آیا یک مستطیل می‌تواند مستطیل دیگری را در خود جای دهد:
```rust
impl Rectangle {
 fn area(&self) -> u32 {
  self.width * self.height
 }

 fn can_hold(&self, other: &Rectangle) -> bool { // متد جدید با پارامتر دیگر
  self.width > other.width && self.height > other.height
 }
}
```
در اینجا `can_hold` نمونه‌ی دیگری از `Rectangle` را به صورت ارجاع غیرقابل تغییر (`&Rectangle`) می‌گیرد.

تمام توابعی که درون یک بلوک `impl` تعریف می‌شوند، **توابع مرتبط (Associated Functions)** نامیده می‌شوند. این توابع با نوع نام‌گذاری شده پس از `impl` مرتبط هستند. می‌توان توابع مرتبطی تعریف کرد که `self` به عنوان اولین پارامتر نداشته باشند (و بنابراین متد نیستند)، زیرا برای کار کردن به یک نمونه از نوع نیاز ندارند. مثالی از چنین تابعی، `String::from` است.

توابع مرتبطی که متد نیستند، اغلب برای **سازنده‌ها (Constructors)** استفاده می‌شوند که یک نمونه‌ی جدید از Struct را برمی‌گردانند. این توابع معمولاً `new` نامیده می‌شوند، اما `new` یک نام خاص نیست و در زبان ساخته نشده است.
مثالی از تابع مرتبط `square` برای Struct `Rectangle` که یک مربع `Rectangle` ایجاد می‌کند:
```rust
impl Rectangle {
 fn square(size: u32) -> Self { // تابع مرتبط، بدون self
  Self { // Self نام مستعار برای Rectangle است
   width: size,
   height: size,
  }
 }
}

fn main() {
 let sq = Rectangle::square(3); // فراخوانی تابع مرتبط با سینتکس ::
}
```
کلمه‌ی کلیدی `Self` در نوع بازگشتی و بدنه‌ی تابع، نام مستعار برای نوعی است که بعد از کلمه‌ی کلیدی `impl` ظاهر می‌شود (در اینجا `Rectangle`). برای فراخوانی یک تابع مرتبط، از سینتکس `::` با نام Struct استفاده می‌کنیم.

هر Struct می‌تواند چندین بلوک `impl` داشته باشد. این سینتکس معتبر است و می‌تواند در موارد پیشرفته‌تر (مانند Generic types و Traits) مفید باشد.

**اضافه کردن قابلیت‌های مفید با Derived Traits (و مدیریت خطا در زمان چاپ)**
زمانی که در حال رفع اشکال (Debugging) برنامه‌ی خود هستیم، اغلب مفید است که بتوانیم یک نمونه از Struct خود را چاپ کرده و مقادیر تمام فیلدهای آن را ببینیم. اگر سعی کنیم یک نمونه `Rectangle` را با استفاده از ماکرو `println!` و placeholder `{}` چاپ کنیم، با خطا مواجه می‌شویم.
کدی که خطا ایجاد می‌کند:
```rust
#[derive(Debug)] // این خط را موقتاً برای نمایش خطا حذف می‌کنیم
struct Rectangle {
 width: u32,
 height: u32,
}

fn main() {
 let rect1 = Rectangle { width: 30, height: 50, };
 println!("rect1 is {}", rect1); // سعی در چاپ با {}
}
```
هنگامی که این کد را کامپایل می‌کنیم، خطایی با پیام کلیدی زیر دریافت می‌کنیم:
`error[E0277]: `Rectangle` doesn't implement `std::fmt::Display``
این خطا می‌گوید که Struct `Rectangle` ویژگی (Trait) `std::fmt::Display` را پیاده‌سازی نمی‌کند. ماکرو `println!` با استفاده از `{}` از قالب‌بندی `Display` استفاده می‌کند که برای نمایش خروجی به کاربران نهایی طراحی شده است. انواع اولیه (Primitive types) مانند اعداد به طور پیش‌فرض `Display` را پیاده‌سازی می‌کنند. اما برای Structها، نحوه‌ی قالب‌بندی خروجی کمتر واضح است (آیا کاما می‌خواهید؟ براکت فرفری؟ همه‌ی فیلدها؟). به دلیل این ابهام، Rust سعی نمی‌کند حدس بزند و Structها به طور پیش‌فرض پیاده‌سازی `Display` را ندارند.

با خواندن ادامه‌ی پیام خطا، یک راهنمایی مفید پیدا می‌کنیم:
`= help: the trait `std::fmt::Display` is not implemented for `Rectangle``
`= note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead`
این راهنمایی پیشنهاد می‌کند از `{:?}` یا `{:#?}` استفاده کنیم. این‌ها به ماکرو `println!` می‌گویند که از فرمت خروجی به نام **Debug** استفاده کند. ویژگی `Debug` به ما امکان می‌دهد Struct خود را به روشی چاپ کنیم که برای توسعه‌دهندگان مفید باشد تا در زمان رفع اشکال، مقادیر آن را ببینند.

بیایید سعی کنیم `println!("rect1 is {rect1:?}");` را استفاده کنیم.
کد با تغییر:
```rust
// #[derive(Debug)] // این خط هنوز حذف شده است
struct Rectangle {
 width: u32,
 height: u32,
}

fn main() {
 let rect1 = Rectangle { width: 30, height: 50, };
 println!("rect1 is {rect1:?}"); // استفاده از :?
}
```
با این تغییر نیز همچنان با خطا مواجه می‌شویم:
`error[E0277]: `Rectangle` doesn't implement `Debug``
اما دوباره، کامپایلر یک راهنمایی مفید می‌دهد:
`= help: the trait `Debug` is not implemented for `Rectangle``
`= note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle``
Rust قابلیت چاپ اطلاعات رفع اشکال را دارد، اما ما باید به صراحت **Opt-in** کنیم تا این قابلیت برای Struct ما در دسترس قرار گیرد. برای این کار، باید **Outer Attribute** به نام `#[derive(Debug)]` را درست قبل از تعریف Struct اضافه کنیم.
کد با اضافه کردن attribute برای Derived کردن Debug:
```rust
#[derive(Debug)] // اضافه کردن attribute
struct Rectangle {
 width: u32,
 height: u32,
}

fn main() {
 let rect1 = Rectangle { width: 30, height: 50, };
 println!("rect1 is {rect1:?}"); // چاپ با :?
}
```
اکنون وقتی برنامه را اجرا کنیم، خطایی نخواهیم گرفت و خروجی زیر را می‌بینیم:
```
rect1 is Rectangle { width: 30, height: 50 }
```
این خروجی تمام مقادیر فیلدهای این نمونه را نشان می‌دهد که در زمان رفع اشکال بسیار کمک‌کننده است. برای Structهای بزرگتر، ممکن است خروجی خواناتر مفید باشد؛ در این موارد، می‌توانیم از `{:#?}` به جای `{:?}` در رشته `println!` استفاده کنیم. این کار باعث می‌شود خروجی با فرورفتگی (Indentation) و خواناتر نمایش داده شود.

راه دیگری برای چاپ یک مقدار با فرمت `Debug`، استفاده از **ماکرو `dbg!`** است. ماکرو `dbg!` مالکیت یک عبارت را می‌گیرد (برخلاف `println!` که ارجاع می‌گیرد)، فایل و شماره‌ی خطی که فراخوانی `dbg!` رخ داده است را همراه با مقدار حاصله‌ی آن عبارت چاپ می‌کند و سپس مالکیت مقدار را برمی‌گرداند. `dbg!` خروجی خود را به جریان خطای استاندارد کنسول (`stderr`) می‌فرستد، در حالی که `println!` به جریان خروجی استاندارد (`stdout`) می‌فرستد.

مثالی از استفاده از `dbg!` برای دیدن مقدار فیلد `width` و همچنین کل Struct:
```rust
#[derive(Debug)]
struct Rectangle {
 width: u32,
 height: u32,
}

fn main() {
 let scale = 2;
 let rect1 = Rectangle {
  width: dbg!(30 * scale), // استفاده از dbg! برای اشکال‌زدایی عبارت
  height: 50,
 };
 dbg!(&rect1); // استفاده از dbg! برای اشکال‌زدایی نمونه Struct (با ارجاع)
}
```
خروجی این کد شبیه به این است:
```
[src/main.rs:10:16] 30 * scale = 60
[src/main.rs:14:5] &rect1 = Rectangle { width: 60, height: 50, }
```
خروجی اول از خط ۱۰ فایل `src/main.rs` است که عبارت `30 * scale` را اشکال‌زدایی می‌کند و مقدار حاصل آن `60` است. فراخوانی `dbg!` در خط ۱۴ فایل `src/main.rs` مقدار `&rect1` را خروجی می‌دهد که Struct `Rectangle` است و از قالب‌بندی pretty `Debug` استفاده می‌کند. ماکرو `dbg!` می‌تواند بسیار مفید باشد زمانی که سعی در فهمیدن نحوه‌ی کار کد خود دارید.

Rust علاوه بر ویژگی `Debug`، تعدادی ویژگی دیگر را نیز فراهم کرده است که می‌توانیم با attribute `derive` از آن‌ها استفاده کنیم تا رفتار مفیدی به انواع سفارشی خود اضافه کنیم.

به طور خلاصه، Structها به شما اجازه می‌دهند انواع سفارشی معنادار ایجاد کنید. با استفاده از Structها، می‌توانید قطعات داده‌ی مرتبط را با هم نگه دارید و هر قطعه را نام‌گذاری کنید تا کدتان واضح باشد. در بلوک‌های `impl`، می‌توانید توابع مرتبط با نوع خود را تعریف کنید، و متدها نوعی تابع مرتبط هستند که به شما اجازه می‌دهند رفتار نمونه‌های Struct خود را مشخص کنید.

</html> 