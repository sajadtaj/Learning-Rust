<div dir='rtl'>


*   **سوال ۱: مرجع (Reference) در راست چیست و چه تفاوتی با اشاره‌گر (pointer) دارد؟**
    **پاسخ ۱:** مرجع مانند اشاره‌گر یک **آدرس** است که می‌توانیم آن را دنبال کنیم تا به داده ذخیره شده در آن آدرس دسترسی پیدا کنیم؛ این داده متعلق به **متغیر دیگری** است. برخلاف اشاره‌گر، مرجع **تضمین** می‌شود که در طول عمر خود به یک **مقدار معتبر** از یک نوع خاص اشاره کند.

*   **سوال ۲: چگونه از مراجع در پارامترهای تابع استفاده می‌شود؟**
    **پاسخ ۲:** از علامت `&` برای ایجاد مرجع استفاده می‌شود. در تعریف تابع، به جای گرفتن مالکیت مقدار (`String`)، نوع پارامتر با استفاده از `&String` مشخص می‌شود که نشان می‌دهد تابع یک **مرجع به `String`** می‌پذیرد. این به شما اجازه می‌دهد **بدون گرفتن مالکیت** به یک مقدار اشاره کنید.

*   **سوال ۳: استفاده از مراجع به جای گرفتن مالکیت چه مزیتی دارد؟**
    **پاسخ ۳:** با استفاده از مرجع، نیازی نیست که برای اینکه بتوانیم از `String` بعد از فراخوانی تابع استفاده کنیم، آن را برگردانیم، زیرا **مالکیت** آن به تابع **منتقل نشده** است. هنگامی که توابع به جای مقادیر واقعی، مراجع را به عنوان پارامتر دارند، نیازی نیست مقادیر را برگردانند تا مالکیت را پس دهند، چون هرگز مالکیتی نداشته‌اند.

*   **سوال ۴: "قرض گرفتن" (Borrowing) در راست به چه معناست؟**
    **پاسخ ۴:** ما به عمل **ایجاد مرجع**، "**قرض گرفتن**" می‌گوییم. همانطور که در زندگی واقعی، اگر شخصی مالک چیزی باشد، شما می‌توانید آن را از او قرض بگیرید. وقتی کارتان تمام شد، باید آن را پس دهید. شما مالک آن نیستید.

*   **سوال ۵: آیا می‌توان داده‌ای را که با مرجع استاندارد (غیر mutable) به آن اشاره می‌شود، تغییر داد؟ چرا؟**
    **پاسخ ۵:** خیر، نمی‌توان داده‌ای را که مرجع استاندارد (توسط `&`) به آن اشاره می‌کند، تغییر داد. همانطور که متغیرها به طور پیش‌فرض **غیرقابل تغییر (immutable)** هستند، مراجع نیز چنین‌اند. تلاش برای تغییر یک مقدار قرض گرفته شده (مثلاً با `push_str`) منجر به **خطای کامپایل** می‌شود که می‌گوید نمی‌توان `*some_string` را به صورت mutable قرض گرفت چون پشت یک مرجع `&` قرار دارد (خطای E0596).

*   **سوال ۶: چگونه می‌توان داده‌های قرض گرفته شده را تغییر داد؟**
    **پاسخ ۶:** برای تغییر یک مقدار قرض گرفته شده، باید از "**مرجع mutable**" (قابل تغییر) استفاده کرد. برای این کار، متغیری که به آن اشاره می‌شود باید `mut` باشد (مثلاً `let mut s`)، مرجع با `&mut` ایجاد شود (مثلاً `&mut s`) و امضای تابع باید مرجع mutable بپذیرد (مثلاً `some_string: &mut String`). این باعث می‌شود واضح باشد که تابع مقدار قرض گرفته شده را **تغییر** خواهد داد.

*   **سوال ۷: مهمترین محدودیت مراجع mutable چیست؟**
    **پاسخ ۷:** مراجع mutable یک محدودیت بزرگ دارند: اگر یک مرجع mutable به یک مقدار دارید، نمی‌توانید هیچ مرجع دیگری (چه mutable و چه immutable) به آن مقدار داشته باشید. به طور همزمان نمی‌توانید **بیش از یک مرجع mutable** به یک داده داشته باشید. تلاش برای ایجاد دو مرجع mutable به `s` در یک زمان منجر به **خطای کامپایل E0499** می‌شود.

*   **سوال ۸: چرا راست قوانین سختگیرانه‌ای در مورد مراجع، به ویژه مراجع mutable دارد؟**
    **پاسخ ۸:** این قوانین به راست اجازه می‌دهند تا **دیتاریس (data race)** را **در زمان کامپایل** جلوگیری کند. دیتاریس زمانی اتفاق می‌افتد که دو یا چند اشاره‌گر همزمان به یک داده دسترسی پیدا می‌کنند، حداقل یکی از آن‌ها برای نوشتن استفاده می‌شود و هیچ مکانیزمی برای همگام‌سازی دسترسی وجود ندارد. دیتاریس‌ها باعث **رفتار نامعین** می‌شوند و تشخیص و رفع آن‌ها در زمان اجرا دشوار است؛ راست با refusing به کامپایل کدی که دیتاریس دارد، از این مشکل جلوگیری می‌کند.

*   **سوال ۹: آیا می‌توان همزمان مراجع mutable و immutable به یک داده داشت؟**
    **پاسخ ۹:** خیر، شما **نمی‌توانید** همزمان یک مرجع mutable و مراجع immutable به همان مقدار داشته باشید. این کار منجر به **خطای کامپایل E0502** می‌شود. کاربران یک مرجع immutable انتظار ندارند که مقدار ناگهان تغییر کند. با این حال، داشتن **چندین مرجع immutable** مجاز است زیرا کسی که فقط داده را می‌خواند، نمی‌تواند بر خواندن دیگران تأثیر بگذارد.

*   **سوال ۱۰: چگونه راست از ایجاد مراجع معلق (dangling references) جلوگیری می‌کند؟**
    **پاسخ ۱۰:** در راست، کامپایلر **تضمین** می‌کند که مراجع هرگز معلق نخواهند بود. اگر شما مرجعی به مقداری دارید، کامپایلر مطمئن می‌شود که داده قبل از مرجع آن، **از scope خارج نشود**. تلاش برای بازگرداندن مرجعی به یک متغیر محلی (مانند `s` در تابع `dangle`) که در پایان تابع از scope خارج و deallocate می‌شود، منجر به **خطای کامپایل** می‌شود (خطاهای E0106 و E0515). راه حل اغلب این است که به جای مرجع، **خود مقدار** (با انتقال مالکیت) برگردانده شود.

</div>